# What is debugging?

Bu kurs boyunca hata ayıklama ve sorun giderme hakkında konuşacağız. Peki aralarındaki fark nedir? Sorun gidermenin sorunları tanımlama, analiz etme ve çözme süreci olduğunu söylüyoruz. Sorun giderme terimini her türlü sorunu çözmek için kullanabiliriz. Bu kursta BT ile ilgili sorunları gidermeye odaklanacağız. Donanımdan, işletim sisteminden veya bilgisayarda çalışan uygulamalardan kaynaklanan sorunlar olabilir. Ayrıca yazılımın ortamından ve yapılandırmasından da kaynaklanabilirler. Uygulamanın etkileşimde bulunduğu hizmetler veya çok çeşitli diğer olası BT nedenleri. Diğer taraftan hata ayıklama, sistemdeki hataları tanımlama, analiz etme ve kaldırma işlemidir. Bazen sorun giderme ve hata ayıklamayı birbirinin yerine kullanırız. Ancak genel olarak, uygulamayı çalıştıran sistemdeki sorunları düzeltirken sorun giderme, uygulamanın gerçek kodundaki hataları düzeltirken ise hata ayıklama diyoruz. Sistem ve sistemimizdeki programların ne yaptığı hakkında daha fazla bilgi almak için kullanabileceğimiz birçok araç bulunmaktadır. **Tcpdump ve Wireshark** gibi araçlar bize devam eden ağ bağlantılarını gösterebilir ve kablolarımız üzerinden geçen trafiği analiz etmemize yardımcı olabilir. **PS, top veya free** gibi araçlar bize sistemde kullanılan kaynakların sayısını ve türlerini gösterebilir. Bir programın yaptığı sistem çağrılarına bakmak için strace, yazılımın yaptığı kütüphane çağrılarına bakmak için ltrace gibi bir araç kullanabiliriz. Bunları ezberleme konusunda endişelenmeyin; gerçek dünyadaki örneklerimizde her biri hakkında ayrıntılı olarak konuşacağız. Bir programın kodunda hata ayıklama yaparken, bu araçları, uygulamayı yazmak için kullanılan programlama diline yönelik geliştirilmiş özel hata ayıklama araçlarıyla birleştirebiliriz. Hata ayıklayıcılar kodu satır satır takip etmemize, değişken atamalarındaki değişiklikleri incelememize, belirli bir koşul karşılandığında programı kesintiye uğratmamıza ve daha pek çok şeye olanak tanır. Bunun da ötesinde, kodu değiştirebilirsek, daha fazla günlük bilgisi sağlayacak şekilde değiştirebiliriz. Bu, perde arkasında neler olup bittiğini anlamamıza yardımcı olabilir. Hem sorun giderme hem de hata ayıklama biraz sanattır. Sorunu daha önce gördüğünüz şanslı durumlarda, çözümün ne olduğunu hemen bilebilirsiniz. Ancak genellikle sorunu anlamak ve çözümünü bulmak biraz yaratıcılık gerektirir. Neyin başarısız olabileceğine dair yeni fikirler ve bunu kontrol etmenin yollarını bulmamız gerekiyor. Ve neyin başarısız olduğunu bildiğimizde, onu nasıl çözeceğimizi hayal etmemiz gerekir. Bir adım daha ileri giderek, bir sorunu çözdükten sonra onun tekrar yaşanmasını nasıl önleyebileceğimizi düşünmeye başlayabiliriz. Son takımımda yaptığım zorlu bir hata ayıklama oturumunu çalıştırıyorum. Yeni bir sürümü otomatik olarak oluşturup dağıtmadan önce hizmetin doğru çalıştığından emin olmak için yakın zamanda işlem hatlarımızdan birine entegrasyon testleri ekledik. Test yaklaşık bir ay boyunca iyi çalıştı ve ardından başarısız olmaya başladı. Bu, bozuk bir sürümün yayınlanmasını önleyecek bir entegrasyon testi olduğundan, bozuk kodun aslında üretim sunucusunda zaten yayında olduğunu keşfetmek beni gerçekten şaşırttı. Tonlarca günlüğe baktım ve kodun ne yaptığını takip etmek için uzun zaman harcadım. Sonunda sorunun, testlerin başlangıçta amaçladığımız gibi test örneği yerine üretim örneğine karşı yürütülmesinden kaynaklandığını fark ettim. Başka bir deyişle, üretim örneği düzgün çalıştığı sürece test başarılı olacaktır. Üretim örneği bozulduğunda da bozulacaktı, bu hiç istediğimiz bir şey değildi. Sorunu çözmek için test kodunun neden entegrasyon testi içinde oluşturduğumuz test örneğine bağlanmadığını bulmam gerekiyordu. Çok daha fazla araştırma yaptıktan sonra, yürütme yolunun yanlış olması nedeniyle test örneğinin başlatılamadığını keşfettim. Bunu düzeltmek için, farklı bir ekip tarafından sağlanan kütüphaneyi doğru parametreyi iletecek şekilde değiştirdim. Ve işte, test artık üretim örneğinde değil, test örneğindeki koda karşı çalışmaya başladı. Sorun giderme veya hata ayıklama sırasında şaşırtıcı durumlarla karşılaşırız. İşler beklendiği gibi çalışmıyor ve nedenini anlamamız ve nasıl çözeceğimizi bulmamız gerekiyor. Daha önce de belirttiğimiz gibi, bu kursta teknik sorunları anlamak ve çözmek için bir dizi farklı tekniği inceleyeceğiz. Bazen sistem tarafına, bazen de kodlama tarafına odaklansak da ele alacağımız tekniklerin çoğu, herhangi bir teknik sorunu çözmemize yardımcı olabilir. Şimdi her türlü teknik sorunu çözmek için atmamız gereken adımlardan bahsedeceğiz.

Throughout this course, we'll be talking about debugging and troubleshooting. So what's the difference between them? We say that troubleshooting is the process of identifying, analyzing, and solving problems. We can use the term troubleshooting to refer to solving any kind of problem. In this course, we'll focus on troubleshooting IT-related problems. They could be problems caused by hardware, the operating system, or applications running on the computer. They could also be caused by the environment and configuration of the software. The services the application is interacting with, or a wide range of other possible IT causes. On the flip side, debugging is the process of identifying, analyzing, and removing bugs in a system. We sometimes use troubleshooting and debugging interchangeably. But generally, we say troubleshooting when we're fixing problems in the system running the application, and debugging when we're fixing the bugs in the actual code of the application. There are lots of tools that we can use to get more information about the system and what the programs in our system are doing. Tools like tcpdump and Wireshark can show us ongoing network connections, and help us analyze the traffic going over our cables. Tools like ps, top, or free can show us the number and types of resources used in the system. We can use a tool like strace to look at the system calls made by a program, or ltrace to look at the library calls made by the software. Don't worry about memorizing them, we'll talk about each in detail in our real-world examples. When debugging the code of a program, we can combine these tools with specific debugging tools developed for the programming language used to write the application. Debuggers let us follow the code line by line, inspect changes in variable assignments, interrupt the program when a specific condition is met, and more. On top of that, if we can modify the code, we can change it so that it provides more logging information. This can help us understand what's going on behind the scenes. Both troubleshooting and debugging are a bit of an art. In those fortunate cases when you've seen the problem before, you might immediately know what the solution is. But usually, figuring out the problem and its solution require some creativity. We need to come up with new ideas of what could be failing, and ways to check for that. And once we know what's failing, we need to imagine how to solve it. To take it a step further, once we've solved a problem, we can start thinking about how to prevent it from happening again. I remember a tricky debugging session that I had on my last team. We recently added integration tests to one of our pipelines to make sure the service worked correctly before automatically building and deploying a new version. The test ran fine for about a month, and then it started to fail. Since this was an integration test that would prevent a broken version from getting released, I was really surprised to discover that the broken code was actually already live in the production server. I looked at tons of logs and spent a long time following what the code did. Finally, I noticed that the problem was that the tests were running against the production instance, instead of the test instance as we originally intended. In other words, the test would pass as long as the production instance was working fine. And would break when the production instance was broken, not what we wanted at all. To fix the problem, I had to figure out why the test code didn't connect to the test instance that we were creating inside the integration test. After a lot more investigation, I discovered that the test instance was failing to start because the execution path was incorrect. To fix this, I ended up modifying a library provided by a different team to pass the right parameter. And voila, the test started running against the code in the test instance, not the production instance anymore. When troubleshooting or debugging, we come across surprising situations. Things aren't working as expected, and we need to understand why, and figure out how to solve it. As we called out, in this course, we'll look into a bunch of different techniques to understand and solve technical problems. While we'll sometimes focus on system side and sometimes on the coding side, most of the techniques that we'll cover can help us solve any technical problem. Up next, we'll talk about the steps we need to take to solve any kind of technical problem.