# Intermittently Failing Script

Bir meslektaşımız yakın zamanda şirketteki kişilere toplantı hatırlatıcıları göndermek için küçük bir uygulama geliştirdi çünkü birisi sürekli gelmeyi unutuyordu. Uygulamayı geçen hafta ilk test eden satış ekibi oldu ve gayet iyi çalıştı. Ancak bu hafta başka bir kullanıcı toplantı hatırlatıcısı göndermeye çalışıyor ve program sürekli hata vererek sonlandırılıyor. Uygulamayı geliştiren meslektaşımız Atlantik'in diğer tarafında olduğundan kullanıcı, neler olup bittiğini anlamak için bizden yardım istiyor. Öncelikle programı kendimiz çalıştırmayı deneyelim ve sorunu yeniden oluşturup oluşturamayacağımızı kontrol edelim. Karşımıza toplantı tarihini, toplantı başlığını ve hatırlatma göndermek istediğimiz kişileri girebileceğimiz bir pencere çıkıyor. Kullanıcının göndermeye çalıştığı toplantı hatırlatıcısı 13 Ocak'a aitti ve başlığı Üretim İncelemesiydi. Bazı şeyleri denediğimiz ve testlerimiz sırasında hatırlatıcılar göndermek istemediğimiz için, bunu hatırlatıcıları buluşmaya gönderecek şekilde ayarlayacağım. E-posta gönderilemedi. Bu, sorunu yeniden oluşturduğumuz anlamına gelir. Geçen hafta satış ekibinin gönderdiği ve bunun iyi sonuç verdiğini hatırlatmaya çalışalım. Bu durumda hatırlatma 7 Ocak için gönderilmişti ve başlığı da Satışlar All Hands idi. Hatırlatıcıları test edecek kişilerin dağılmasını önlemek için bunu bir kez daha kendime göndereceğim. Evet. Bu durumda program hatırlatmayı başarıyla gönderdi. Sizce hangi parametre hatalı? Başlık mı yoksa tarih mi? Her ikisi de olabilir. Ama bunun tarih olduğuna bahse girerim. Tarih olarak 13 Ocak ve Başlığı Her Elden Satış olmak üzere bir kez daha deneyelim. Başka bir başarısızlık. Yani bir üreme durumumuz var. 13 Ocak için toplantı hatırlatıcısını göndermeye çalıştığımızda başarısızlık mesajını alıyoruz. Ancak aynı hatırlatmayı 7 Ocak için göndermeye çalışırsak işe yarar. Şimdi bir sonraki adım sorunun temel nedenini bulmaktır. Uygulamamız neden 7 Ocak'ta düzgün çalışıp 13 Ocak'ta başarısız oluyor? Bir sürü sebep olabilir. Ancak genel olarak tarihler bir hataya karıştığında sorun, tarihlerin nasıl biçimlendirildiğinden kaynaklanır. Bazı ülkelerde tarihler ay birincisi ve ikinci gün olacak şekilde yazılır. Diğer ülkelerde ise durum tam tersi. Neler olduğunu anlamak için programa daha fazla hata ayıklama bilgisi ekleyelim. Bash ile yazılmış bir script olan meet_reminder.sh scriptini açacağız. Bu scriptin Zenity isimli bir programı çağırdığını görüyoruz. Zenity, tarihi, başlığı ve e-postaları seçmek için pencereyi gösteren uygulamadır. Zenity tarafından oluşturulan çıktı, meet_info adı verilen bir değişkende saklanır ve bu daha sonra send_reminders.py, Python 3 betiğine parametre olarak aktarılır. Bu komut dosyası daha sonra e-postaları gönderir. Zenity tarafından oluşturulan çıktı hakkında daha fazla bilgi edinmek için Python betiği çağrılmadan önce meet_info değişkeninin değerini görmek istiyoruz. Bunu görmek için bir echo ifadesi ekleyelim. Bunu kaydedip tekrar deneyelim. Sorunun tarihle ilgili olduğunu bildiğimiz için bu sefer toplantı başlığı olarak sadece test kullanacağız. Zenity'nin ürettiği bilgilerin borulara bölündüğünü ve verilerin ay, gün, yıl olarak formatlandığını görüyoruz. Bu zaten değerli bir bilgi. Şimdi, bir sonraki adım daha bilgilendirici bir hata almaktır. Bunu yapmak için hatırlatıcıları gönderen Python betiğini açalım ve daha iyi bir hata yazdırıp yazdıramayacağımıza bakalım. Dosya uzun olduğundan, programın temel işlevlerini listeleyen ana işleve bakarak başlamak mantıklıdır. Alma parametresini üçe böldüğünü, ardından gönderilecek mesajı hazırladığını ve son olarak gönderdiğini görüyoruz. Her şey yolunda giderse başarıyla gönderildiğini belirten bir mesaj yazdırır. Ancak herhangi bir şey başarısız olursa, daha önce gördüğümüz hata mesajını yazdırır. Ancak hata mesajı pek kullanışlı değil çünkü işlerin başarısız olmasının nedenlerini gizliyor. Hatayı oluşturan istisnayı da yazdırarak bu hatayı daha yararlı hale getirelim. Kaydedip tekrar deneyelim. Bu sefer sorunun, kullandığımız tarih formatının ayı ilk sıraya koyması, ancak programın ayın ikinci olmasını beklemesi olduğunu görüyoruz. 13. ay olmadığından bu geçersiz bir tarihtir. Böylece sorunun temel nedenini bulduk. Program, belirli bir tarih formatını varsayarak tarihi dönüştürmeye çalışıyor, ancak biz farklı bir format kullanıyoruz. Artık bildiğimiz gibi, temel nedeni öğrendikten sonraki adım sorunu düzeltmektir. Bu durumda sorunu gidermek için ne yapabiliriz? Programı, tarih formatımızı kullanacak şekilde değiştirebiliriz, ancak bu durumda uygulama, onu farklı bir konumda çalıştıran kişiler için çalışmayacaktır. Yapmamız gereken, betiği nerede çalıştırırsak çalıştıralım Zenity tarafından oluşturulan tarihin Python tarafından beklenen tarihle eşleştiğinden emin olmaktır. Neyse ki Zenity istediğimiz formatı belirleyecek bir parametre içeriyor. Bu nedenle kabuk betiğini -- formlar-date-format parametresini kullanacak şekilde değiştireceğiz ve formatı, uluslararası standart tarih formatı olan %y -%m-%d olarak ayarlayacağız. Bununla Zenity, tarihi uluslararası formatta döndürecek. Şimdi Python betiğini aynı formatı kullanacak şekilde değiştirmemiz gerekiyor. Belirtilen formata sahip fonksiyona gidip onu aynı formata değiştireceğiz. Harika. Artık Zenity tarafından oluşturulan tarih formatı her zaman Python tarafından okunan formatla eşleşmelidir. Bu senaryo ülkemizde ve diğer ülkelerde çalışmalıdır. Hadi deneyelim ve gerçekten düzelip düzelmediğini kontrol edelim. Sorunu başarıyla düzelttik. Ne yaptığımızı hızlıca özetleyelim. Önce sorunu kendimiz yeniden oluşturduk, ardından hangi girdinin sorunu tetiklediğini, hangisinin tetiklemediğini bulduk. Daha sonra komut dosyalarına daha fazla hata ayıklama bilgisi ekledik; bu, sorunun temel nedenini, yani bu Zenity çağrısı tarafından kullanılan tarih formatları ile Python komut dosyası arasındaki uyumsuzluğu bulmamıza yardımcı oldu. Son olarak her ikisinin de aynı tarih biçimini kullandığından emin olarak sorunu düzelttik. Sırada, son videolarda ele aldığımız kavramların hepsinin anlamlı olup olmadığını kontrol etmek için başka bir testimiz var.

A colleague recently developed a small application to send meeting reminders to people in the company, because someone kept forgetting to show up. The sales team was the first to test the app last week, and it worked fine. But this week, another user is trying to send a meeting reminder and the program keeps terminating with an error. Since the colleague that developed the app is on the other side of the Atlantic, the user is asking for our help to figure out what's going on. First, let's try running the program ourselves and check if we can reproduce the problem. We're presented with a window where we can enter the date for the meeting, the title of the meeting, and the people that we want to send the reminder to. The meeting reminder that the user was trying to send was for January 13th, and the title was Production Review. As we are trying things out and don't want to be mailing reminders out with our tests, I'll set this one to send the reminders to meet. It failed to send the email. This means we've reproduced the issue. Let's try reminder that the sales team sent last week which had worked fine. In that case, the reminder had been sent for January 7th and the title was Sales All Hands. Again, I'll send this to myself to avoid spanning people would test reminders. Yes. In this case, the program successfully sent the reminder. Which parameter do you think is at fault? The title or the date? It could be either. But I'll bet it's the date. Let's try it once more with January 13th as the date and Sales All Hands as the title. Another failure. So we have a reproduction case. When we try to send the meeting reminder for January 13th, we get the failure message. But if we try to send the same reminder for January 7th, it works fine. Now, the next step is to find the root cause of the issue. Why could our application work fine for January 7th but fail for January 13th? There could be a bunch of reasons. But in general, when dates are involved in a failure, the problem is due to how the dates are formatted. In some countries, the dates are written with the month first and the day second. While in other countries, it's the other way around. To figure out what's going on, let's add more debugging information to the program. We'll open the meeting_reminder.sh script, which is a script written in Bash. We see that this script is calling a program called Zenity. Zenity is the application showing the window to select the date, title, and emails. The output generated by Zenity is stored in a variable called meeting_info, which is then passed as a parameter to the send_reminders.py, Python 3 script. This script then sends the emails. To get more information about the output generated by Zenity, we'd like to see the value of the meeting_info variable before the Python script gets called. Let's add an echo statement to see that. Let's save this and try again. This time, we'll just use test as the meeting title, as we know the problem is with the date. We see that the information generated by Zenity is split by pipes, and that the data is formatted as month, day, year. That's already valuable information. Now, the next step is getting a more informative error. To do that, let's open the Python script that sends the reminders, and see if we can make it print a better error. The file is long, so it makes sense to start by looking at the main function that lists the core functionality of the program. We see that it splits the parameter receive in three, then prepares the message to be sent, and finally sends it. If everything works fine, it prints a message saying that it was sent successfully. But if anything fails, it prints the error message that we've seen already. But the error message is not very useful, as it's hiding the reasons why things failed. Let's make this error more helpful by also printing the exception that generated the failure. Let's save and try again. This time we see that the problem is that the date format we are using is putting the month first, but the program is expecting to have the month second. As there's no month 13, this is an invalid date. So we found the root cause of the problem. The program is trying to convert the date assuming one specific date format, but we're using a different format. As we now know, once we know the root cause, the next step is to remediate the issue. What can we do in this case to remediate the problem? We could change the program to use our date format, but then the application would break for people running it in a different location. What we need to do is make sure that no matter where we run the script, the date generated by Zenity matches the date expected by Python. Fortunately, Zenity includes a parameter to specify any format we want. So we'll change the shell script to use the -- forms-date-format parameter and set the format to %y -%m-%d, which is the international standard date format. With that, Zenity will return the date in the international format. Now, we need to change the Python script to use the same format. We'll go to the function that has the format specified and change it to the same format. Great. Now, the date format generated by Zenity should always match the one read by Python. This script should work in our country and any others. Let's try it out and check if it's really fixed. We've successfully fixed the issue. Let's quickly recap what we did. We first reproduced the problem ourselves, then found which input triggered the issue and which one didn't. We then added more debugging information to the scripts, which helped us find the root cause of the problem, a mismatch between the date formats used by this Zenity invocation and the Python script. Finally, we fixed the issue by making sure that both were using the same date format. Up next, we've got another quiz to check that the concepts we've covered in the last videos are all making sense.