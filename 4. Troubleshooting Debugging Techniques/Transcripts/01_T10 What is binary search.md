# What is binary search?

Genellikle bir sorunun temel nedenini bulmaya çalışırken, pek çok yanıtın bulunduğu listede tek bir yanıt ararız. Listedeki bir öğeyi aramak, bilgi işlemde yaygın bir sorundur. Aradığımız öğeyi bulmamıza yardımcı olabilecek birçok farklı algoritma vardır. Örneğin, şirketinizde çalışan çalışanların verilerini içeren bir listeniz olduğunu ve belirli bir çalışanı bulmak istediğinizi varsayalım. Olası bir yaklaşım, ilk girdiden başlamak ve ardından adın aradığımız ad olup olmadığını kontrol etmek olabilir. Eşleşmiyorsa ikinci öğeye geçip tekrar kontrol edin ve aradığımız isimdeki çalışanı bulana veya listenin sonuna gelene kadar devam edin. Buna doğrusal arama denir. Bu tür bir arama işe yarar ancak liste ne kadar uzun olursa, o kadar uzun sürebilir. Yani sonuca ulaşmak için geçen süre listenin uzunluğuyla orantılıdır. Liste sıralanırsa ikili arama adı verilen alternatif bir arama algoritması kullanabiliriz. Liste sıralı olduğundan elemanların listedeki konumu hakkında kararlar verebiliyoruz. Yani yaptığımız ilk şey, aradığımız ismi listenin ortasındaki elemanla karşılaştırmak ve eşit mi, küçük mü yoksa büyük mü olduğunu kontrol etmek. Daha küçükse aradığımız elemanın listenin ilk yarısında olması gerektiğini biliyoruz. Diğer taraftan, eğer daha büyükse listenin ikinci yarısında olduğunu biliyoruz. Bu şekilde, tek bir karşılaştırmayla, elemanın bulunabileceği olası adaylar arasından listenin yarısını elemiş oluyoruz ve ardından elemanı bulana kadar aynı şeyi tekrar tekrar yapıyoruz. Yani aradığımız element ortadaki elementten küçükse ilk yarının ortasındaki elemente bakarız. Eğer elementimiz artık daha büyükse, ikinci çeyreğin ortasındaki elemente bakarız ve bu böyle devam eder. Aradığımız elemanı bulana kadar uğraştığımız bölümün orta elemanına her baktığımızda. Doğrusal aramayı kullanarak, 1000 öğeli bir listeyi incelemek, aradığımız öğenin listedeki son öğe olması veya hiç mevcut olmaması durumunda 1000'e kadar karşılaştırma gerektirebilir. 1000 öğeden oluşan aynı liste için ikili arama kullanıldığında en kötü durum yalnızca 10 karşılaştırmadır. Bu, liste uzunluğunun iki tabanlı logaritması olarak hesaplanır ve liste ne kadar uzun olursa, faydalar da o kadar önemli olur. 100.000 öğeden oluşan bir liste için bu, 100.000 karşılaştırma yerine 17 karşılaştırma olacaktır. Ancak bunun işe yaraması için listenin sıralanması gerektiğini unutmayın. Yani liste sıralanmazsa, önce onu sıralamamız gerekir, bu da çok zaman alır. Birkaç kez arama yapacaksak yine de bunu yapmak mantıklı olabilir, ancak listeyi sıralayıp ardından yalnızca bir öğeyi bulmak için ikili aramayı kullanmak mantıklı değildir. Bu durumda doğrusal aramayı kullanmak daha basit ve hızlıdır. Bu iki arama türünün Python'da uygulandığında nasıl göründüğünü merak ediyorsanız, bir sonraki okumada doğrusal aramanın ve ikili aramanın olası bir uygulamasını görebilirsiniz. Bundan sonra ikili arama ilkelerini sorun gidermeye nasıl uygulayabileceğimizi konuşacağız.

Usually when trying to find the root cause of a problem, we'll be looking for one answer in a list of many. Searching for an element in a list is a common problem in computing. There are a bunch of different algorithms that can help us find the element that we're looking for. Say for example, you have a list that contains the data of employees that work at your company and you want to find one specific employee. One possible approach would be to start from the first entry and then check if the name is the one that we're looking for. If it doesn't match, move to the second element and check again, and keep going until we find the employee with the name we're looking for, or we get to the end of the list. This is called a linear search. This type of search works but the longer the list, the longer it can take. In other words, the time it takes to find the result is proportional to the length of the list. If the list is sorted, we can use an alternative algorithm for searching called binary search. Because the list is sorted, we can make decisions about the position of the elements in the list. So the first thing we do is compare the name that we're looking for with the element in the middle of the list and check if it's equal, smaller, or bigger. If it's smaller, we know that the element we're looking for must be in the first half of the list. On the flip side, if it's bigger, we know that it's in the second half of the list. This way, with only one comparison, we've eliminated half of the list from possible candidates where the element could have been found, and then we do the same thing again and again until we find the element. So if the element we were looking for was smaller than the middle element, we look at the element in the middle of the first half. If our element is now bigger, we look at the element in the middle of the second quarter, and so on. Each time we look at the middle element of the section we're dealing with, until we find the element we're looking for. Using linear search, going through a list with 1000 elements might take up to 1,000 comparisons if the element we're looking for is the last one in the list or isn't present at all. Using binary search for the same list of 1,000 elements, the worst-case is only 10 comparisons. This is calculated as the base two logarithm of the lists length, and the benefits get more and more significant the longer the list. For a list of 100,000 elements, it would be 17 comparisons instead of 100,000 comparisons. But remember, that for this to work, the list needs to be sorted. So if the list isn't sorted, we would need a sort it first, which takes a chunk of time. It can still make sense to do it if we're going to search through it several times but it doesn't make sense to sort the list and then use binary search to only find one element. In that case, using linear search is simpler and faster. If you're curious about what these two types of search look like when implemented in Python, you can see a possible implementation of linear search and one for binary search in the next reading. After that, we'll talk about how we can apply the principles of binary search to troubleshooting.