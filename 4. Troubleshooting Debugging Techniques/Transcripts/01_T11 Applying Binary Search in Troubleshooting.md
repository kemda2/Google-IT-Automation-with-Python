# Applying Binary Search in Troubleshooting

Biz buna ikili arama algoritması diyoruz. Sıralanmış bir listede bir öğeyi bulmaya çalışırken gerçekten etkilidir. Sorun gidermede, uzun bir hipotez listesini gözden geçirmemiz ve test etmemiz gerektiğinde bu fikri uygulayabiliriz. Bunu yaparken, öğe listesi sorunun olası tüm nedenlerini içerir ve tek bir seçenek kalana kadar sorunu yarıya indirmeye devam ederiz. Öğelerin listesi bir dosyadaki girişler, etkinleştirilen uzantılar, bir sunucuya bağlı kartlar ve hatta hatalı bir sürüme eklenen kod satırları olabilir. Her yinelemede sorun yarı yarıya azalır. Bu yaklaşıma bazen ikiye bölmek anlamına gelen ikiye bölme denir. Daha önceki bir videoda, eski konfigürasyon dizini mevcutken başlatılamayan bir programın yeni versiyonunun örneğini vermiştik. Dizin içinde bir grup farklı dosya varsa, dosya listesini ikiye bölerek hataya neden olan dosyayı belirleyebiliriz. Eski dizinin 12 farklı yapılandırma dosyası içerdiğini varsayalım. Bu 12 kişiden hangisinin arızaya neden olduğunu belirlemek istiyoruz. Bunu yapmak için, 12 dosyadan yalnızca altısını içeren dizinin bir kopyasını oluşturabilir ve ardından programı yeniden başlatmayı deneyebiliriz. Eğer çökerse, hatalı dosya bu altı dosya arasında yer alır. Eğer değilse diğer altısı arasındadır. Bir sonraki adımda başarısız olan altı kişilik gruptan üçünü seçeceğiz. Program tekrar çökerse bu üçünden biri olur. Eğer değilse, diğer üçünden biridir. Son üçü için önce ikisini birlikte kontrol edebiliriz veya tek tek gidebiliriz. Her iki durumda da, başarısız olan dosyaya ulaşmak için iki kontrol yapılması gerekir. Bu, toplam dört denemeyle 12 dosyadan hangisinin soruna neden olduğunu bulabileceğimiz anlamına gelir. BT'de işler bazen karmaşık ve iç içe geçmiş olabileceğinden, zafer ilan etmeden önce programın tek dosya varken çöktüğünü ve tek dosya yokken çökmediğini doğrulamak istiyoruz. Bunu doğruladıktan sonra, sorunumuzun çoğaltma durumunu bütün bir dizin yerine tek bir dosyaya indirgedik, anlaşılması ve neler olduğunu anlamak çok daha kolay. Bundan sonra, dosyanın soruna neden olan belirli bölümünü bulana kadar, o tek dosyanın içeriğini tekrar tekrar ikiye bölerek aynı şekilde ilerleyebiliriz. Aynı süreç çok çeşitli problemlere uygulanabilir. Örneğin, hangi tarayıcı uzantısının tarayıcının çökmesine neden olduğunu bulmak, uzantıların yarısını devre dışı bırakmak, ardından tarayıcının bu alt kümeyle çöküp çökmediğini kontrol etmek ve hatalı uzantıyı bulana kadar bu şekilde devam etmek çok yaygındır. Bu tekniği ayrıca masaüstü ortamındaki hangi eklentinin bilgisayarın belleğinin dolmasına neden olduğunu veya veritabanındaki hangi girişin programın istisna oluşturmasına neden olduğunu keşfetmek için de kullanabiliriz. Son sürümde ortaya çıkan bir hatayı bulmaya çalışırken bunu koda da uygulayabiliriz. Bir sürümden diğerine yapılan değişikliklerin listesini biliyorsak, hataya neden olan sürümü bulana kadar bu listeyi yarıya indirmeye devam edebiliriz. Git'i sürüm kontrolü için kullanırken bisect adı verilen Git komutunu kullanabiliriz. Bisect, Git geçmişinde iki zaman noktası alır ve bozulmaya neden olan işlemi bulana kadar tekrar tekrar ikisinin ortasındaki kodu denememize izin verir. Bunun Git deponuz olmasına bile gerek yok. Git'i izleyen açık kaynaklı bir yazılım kullanıyorsanız, yazılımın bilgisayarınızda hangi komutun çalışmayı durdurmasına neden olduğunu bulmak için bisect commit'i kullanabilirsiniz. Örneğin, Linux çekirdeğinin en son sürümü bilgisayarınızdaki ses kartının çalışmasının durmasına neden oluyorsa, onu bozan işlemi bulmak için Git bisect'i kullanabilir ve bunu düzeltilmesi gereken bir hata olarak bildirebilirsiniz. İkili aramadan bahsederken de belirttiğimiz gibi, kontrol edilmesi gereken öğelerin listesi ne kadar uzun olursa, her yinelemede problemimizi yarıya indirerek o kadar kazançlı çıkacağız. İşaretlenmesi gereken yalnızca beş seçenek varsa, tek tek gidebiliriz. Çok fazla bir fark yaratmayacak ve denediğimiz şeyleri takip etmek daha kolay olabilir. Ama eğer 100 ise, kesinlikle problemi ikiye bölerek cevabı yedi adımda bulabilmek isteriz. 100 değil. Arızaya neden olanı bulmak için bir grup farklı seçeneği test etmemiz gerektiğinde, bunu kontrol etmenin hızlı ve kolay bir yolunu isteriz. Sorunu ikiye bölerek deneme sayısını azaltıyor olsak bile her kontrolde uzun zaman harcamak istemiyoruz. Bazen basittir. Program ya başlar ya da başarısız olur. Ancak diğer zamanlarda neyi kontrol etmek istediğimizi kontrol etmek için bir dizi manuel adım gerekebilir. Dolayısıyla, bulmaya çalıştığımız sorunun ne olduğuna bağlı olarak, sorunu kontrol eden bir komut dosyası oluşturmak için biraz zaman harcamak mantıklı olabilir. Sırada, bunu pratik bir örnekte çalışırken göreceğiz

We call that the binary search algorithm. It's really efficient when trying to find an element in a sorted list. In troubleshooting, we can apply this idea when we need to go through and test a long list of hypotheses. When doing this, the list of elements contains all the possible causes of the problem and we keep reducing the problem by half until only one option is left. The list of elements could be entries in a file, extensions enabled, boards connected to a server, or even lines of code added to a faulty release. With each iteration, the problem is cut in half. This approach is sometimes called bisecting which means dividing in two. In an earlier video, we gave the example of a new version of a program that fail to start when the old configuration directory was present. If the directory contained a bunch of different files in it, we could identify the one causing the failure by bisecting the list of files. Say the old directory contained 12 different config files. We want to identify which of those 12 is causing the failure. To do that, we can create a copy of the directory with just six of the 12 files and then try to start the program again. If it crashes, then the bad file is among those six files. If it doesn't, it's among the other six. In the next step, we would pick three out of the failing group of six. If the program crashes again, it's one of those three. If it doesn't, it's one of the other three. For the last three, we can first check two together or just go one by one. Either way, it's two checks to get to the failing file. This means that with a total of four attempts, we can find out which of the 12 files is causing the problem. Since things in IT can sometimes be complex and intertwined, before declaring victory, we want to verify that the program crashes with that single file present and doesn't crash when the single file isn't present. Once we've confirmed that, we've reduced the reproduction case of our problem to a single file instead of a whole directory much easier to understand and figure out what's going on. After that, we can proceed in the same way with the contents of that single file, cutting it in half repeatedly, until we find the specific part of the file that's causing the problem. The same process can be applied to a large variety of problems. It's very common for example to use it to figure out which browser extension is causing the browser to crash, disabling half of the extensions then checking if the browser crashes with that subset and so on until we find the faulty extension. We can also use this technique to discover which plug-in in a desktop environment is causing the computer to run out of memory, or which entry in a database is causing the program to raise an exception. We can also apply this to code when trying to find a bug that was introduced in a recent version. If we know the list of changes that were made between one version and the next, we can keep cutting that list in half until we find the one that caused the failure. When using Git for version control, we can use a Git command called bisect. Bisect receives two points in time in the Git history and repeatedly lets us try the code at the middle point between them until we find the commit that caused the breakage. This doesn't even need to be your Git repository. If you're using open source software that's tracking Git, you can use the bisect commit to find out which command cause the software to stop working on your computer. For example, if the latest release of the Linux kernel causes the sound card on your computer to stop working, you can use Git bisect to find the commit that broke it and report this as a bug to be fixed. As we called out when we were talking about binary search, the longer the list of items that needs to be checked, the more we'll gain by cutting our problem in half on each iteration. If it's just five options that need to be checked, we can simply go one-by-one. It won't make a lot of difference and it might be easier to keep track of what we tried. But if it's a 100, we definitely want to bisect the problem so we can find the answer in seven steps. Not a 100. When we have to test a bunch of different options to find the one that's causing a failure, we'll want a quick and easy way to check it. Even if we're reducing the amount of attempts by bisecting the problem, we don't want to spend a long time on each check. Sometimes it's straightforward. Either the program starts or it fails. But other times, it can take a bunch of manual steps to check what we want to check. So depending on what the problem is that we're trying to find, it might make sense to spend some time creating a script that checks for the issue. Up next, we'll see this in action in a practical example