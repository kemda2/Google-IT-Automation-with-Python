# Finding Invalid Data

Olası nedenler listesindeki bir sorunun nedenini, sorunu ikiye bölerek ve her yarıyı ayrı ayrı test ederek nasıl hızlı bir şekilde bulabileceğimizi tartıştık. Bunu bir örnekle uygulamalı olarak görelim. CSV dosyasındaki verileri okuyan, işleyen ve ardından veritabanına aktaran bir programımız var. Sistemin kullanıcılarından biri bize, içe aktarmaya çalıştığı dosyanın belirsiz bir içe aktarma hatasıyla başarısız olduğunu söylüyor. Kendimiz deneyebilmemiz için bize dosyayı gönderdiler. Komutu çağırmak için kullanıcının bize gönderdiği cat contact.csv dosyasının çıktısını import.py komutuna bağlayacağız. Ancak komutu çalıştırmadan önce üretimde test yapmamamız gerektiğini hatırlamanın tam zamanı. Ve bu betik veriyi bir veritabanına aktarmaya çalışacağı için onu üretim veritabanı yerine test veritabanında çalıştırmalıyız. Bunu yapmak için veritabanı sunucusunun adını alan --server bayrağını kullanacağız ve ardından parametre olarak testi geçeceğiz. [SES] Dosyanın içe aktarma hatasıyla başarısız olduğunu ve neyin başarısız olduğu konusunda bize pek fazla bilgi vermediğini görüyoruz. Peki bu dosya ne kadar büyük? Editör ile açıp kontrol edebiliriz ama buna gerek yok. Bir dosyadaki karakterleri, kelimeleri ve satırları sayan **wc** komutunu kullanabiliriz. Özellikle, **wc -l** bir dosyadaki satır miktarını yazdıracaktır. Yani dosyamızda 100 satır var, bu çok fazla. Neyin yanlış olabileceğini bulmak için o listeye bakmak zorunda kalmak istemiyoruz, özellikle de bunun ne olabileceği hakkında hiçbir fikrimiz olmadığı için. Bunun yerine dosyanın yalnızca yarısını betiğe aktarmayı deneyebilir ve başarılı olup olmadığını kontrol edebiliriz. Başarısız olursa, dosyanın o kısmını alıp yarısıyla tekrar kontrol ederiz. İthalatımız başarılı olursa diğer yarısını alıp ikiye bölüyoruz. Gerektiğinde parçaları eklemek veya kaldırmak için dosyayı manuel olarak düzenleyebiliriz, ancak bu sıkıcı olur. Bunun yerine, bunu daha az çabayla yapmamıza yardımcı olacak elimizdeki araçları kullanabiliriz. Dosyadaki ilk satırları yazdırmak için **head** komutunu, son satırları yazdırmak için **tail** komutunu kullanabiliriz. Dahil etmek istediğimiz satır sayısını parametre olarak iletebiliriz. Yani **head -15** ilk 15 satırı, **tail -20** ise son 20 satırı yazdıracaktır. Tamam, daha önce de gördüğümüz gibi, komutumuz içe aktarılacak dosyayı standart girdiden okur. Böylece baş veya kuyruk komutlarımızın çıktısını ona bağlamak için boruları kullanabiliriz. Şimdi dosyanın ilk yarısını girmeyi deneyelim. Tamam, ilk yarı başarısız oldu, tekrar paylaşalım. Bunu yapmak için önceki sayının yalnızca yarısını alacak başka bir boru kullanacağız. Bu şekilde, her adımda, karşılık gelen boyut için başa veya kuyruğa bir çağrı ekleyeceğiz. Bu sefer başardı, yaşasın. Bu, arızanın dosyanın ikinci çeyreğinde olması gerektiği anlamına gelir. O kısmı komutumuza vererek durumun böyle olduğunu doğrulayalım. Bunu yapmak için ilk yarıyı yazı kullanarak, ikinci yarısını da kuyruk kullanarak alacağız. [SES] Bu yine başarısız oldu, ama bu iyi, doğru yolda olduğumuz anlamına geliyor. Bir kez daha bölelim. Harika, test setimiz küçülüyor, hadi bir kez daha bölelim. Tamam, altı başvurumuz kaldı ve bunlardan birinin kötü olduğunu biliyoruz. Hadi bir kez daha döndürelim ve sonra kalan üç girdiye bakabiliriz. Pekala, kalan üç girişe bakalım ve suçluyu bulabilecek miyiz görelim. Sorunu görebiliyor musun? Bu virgülle ayrılmış bir dosyadır. Bu, her virgülün dosyadaki alanlar arasında ayırıcı olarak kullanıldığı anlamına gelir. Bir alan virgül içeriyorsa tırnak arasına yazılmalıdır. Ama burada baktığımız üçüncü satırda ortadaki baştan sonra nokta yerine virgül olduğunu ve bunun tırnak arasına yazılmadığını görüyoruz. Bu satırda çok fazla alan olduğundan içe aktarılan komut dosyası karışır. Tamam, dosyayı düzenleyip düzeltelim. Şimdi ithalatçımızı sabit dosyayla tekrar çalıştıralım. Yaşasın, dosyadaki sorunu düzelttik. Bisect yöntemini kullanarak, 100 satırdan hangi satırın bozuk veriyi içerdiğini çok hızlı bir şekilde bulduk. Daha sonra sorunu düzeltebilir ve başarılı bir şekilde içe aktarabiliriz. Buradaki kısa vadeli iyileştirme, kullanıcımıza ne bulduğumuzu ve bunu nasıl düzeltebileceğimizi anlatmaktır, böylece verileri üretim veritabanına aktarabilirler. Uzun vadeli çözüm, öncelikle dosyanın neden geçersiz alanla oluşturulduğunu bulmak ve bunun bir daha olmayacağından emin olmaktır. İkiye bölme bilginizi eyleme geçirmenize yardımcı olacak başka bir pratik testiyle karşınızdayız.

We have discussed how we can quickly find out the reason for a problem in a list of possible reasons by splitting the problem in half and testing each half separately. Let's see this in action with an example. We have a program that reads data from a CSV file, processes it, and then imports it into a database. One of the users of the system tells us that the file they're trying to import fails with an obscure import error. They've sent us the file so we can try it ourselves. To call the command, we'll connect the output of cat contacts.csv, the file that the user sent us, to the import.py command. But before we run the command, it's a good time to remember that we shouldn't test in production. And since this script is going to be trying to import data into a database, we should run it against the test database instead of the production database. To do that, we'll use the --server flag that takes the name of the database server, and then we'll pass the test as the parameter. [SOUND] We see that the file fails with an importing error, and doesn't give us a lot of information about what's failing. And how big is that file? We could open it with an editor and check, but we don't need to. We can use the wc command that counts characters, words, and lines in a file. In particular, wc -l will print the amount of lines in a file. So our file has 100 lines in it, that's a lot. We don't want to have to go looking through that list to find out what could be wrong, especially since we have no idea what that might be. Instead, we can try passing only half of the file to the script and check if it succeeds or fails. If it fails, then we pick up that part of the file and check again with half of it. If our import succeeds, then we take the other half and split it in two. We could edit the file manually to add or remove the parts as needed, but that would be tedious. Instead, we can use the tools available to us to help us do that with less effort. We can use the head command to print the first lines in the file, and the tail command to print the last lines. We can pass the amount of lines we want to include as a parameter. So head -15 will print the first 15 lines, while tail -20 will print the last 20 lines. Okay, and as we saw earlier, our command reads the file to import from standard input. So we can use pipes to connect the output of our head or tail commands to it. Let's try to input the first half of the file now. Okay, so the first half failed, let's split it again. To do that, we'll use another pipe to take only half of the previous number. This way, in each step, we'll add a call to head or tail for the corresponding size. This time, it succeeded, hooray. This means that the failure must be in the second quarter of the file. Let's verify that that's the case by giving that part to our command. To do that, we'll take the first half using head, then get the second half of it using tail. [SOUND] This fails again, but that's good, it means we're on the right track. Let's split it once again. Great, our test set is getting smaller, let's split it once more. Okay, we're down to six entries, and we know that one of them is the bad one. Let's spin it one more time, and then we can look at the three remaining entries. All right, let's look at the three entries left and see if we can find the culprit. Can you see the problem? This is a comma separated file. This means that each comma is used as a separator between the fields in the file. If a field includes commas, it should be written between quotes. But in the case of the third line we're looking at here, we can see that there's a comma instead of a period after the middle initial, and this is not written between quotes. The importing script is then confused because there are too many fields in this line. Okay, let's edit the file and fix it. And now let's run our importer again with the fixed file. Yay, we fixed the problem in the file. Using the bisect method, we very quickly found which line out of 100 lines contained the corrupt data. And then we could fix it and successfully import it. The short-term remediation here is to tell our user about what we found and how to fix it, so that they can import the data into the production database. The long-term remediation is to figure out why the file was generated with the invalid field in the first place, and make sure that it doesn't happen again. Coming up, another practice quiz to help put your bisecting knowledge into action.