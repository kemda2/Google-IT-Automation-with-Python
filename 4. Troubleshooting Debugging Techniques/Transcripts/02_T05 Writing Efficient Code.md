# Writing Efficient Code

Rolünüz gereği, bir IT uzmanı veya sistem yöneticisi olarak görev yaparken, muhtemelen görevleri otomatikleştirmek için betikler yazmanız gerekecek. Bir kod parçası, tek bir şeyi yapan basit bir betik olarak başlayabilir, ancak sonunda birçok farklı görevi ele alan karmaşık bir programa dönüşebilir ve kodumuzun boyutu ve karmaşıklığı ne olursa olsun, genellikle iyi performans göstermesini istemekteyiz. Bu ve önümüzdeki birkaç video boyunca, kodumuzu daha verimli hale getirmenin ve yavaşsa nelerin düzeltilmesi gerektiğini nasıl bulacağımızın bazı fikirlerini tartışacağız. Ancak unutmamamız gereken önemli bir şey, her zaman öncelikle yapması gerekeni yapan açık bir kod yazmaya başlamamız ve yavaş olmadığını fark edersek sadece daha hızlı yapmaya çalışmamız gerektiğidir. Eğer beş saniyede çalışacak bir betik yazmak için 10 dakika harcıyorsanız ve aynı şeyi yapacak ancak üç saniye sürecek bir betik için 20 dakika harcarsanız, bu fark eder mi? Her şey betiği ne sıklıkla çalıştıracağınıza bağlıdır. Eğer bir gün bir kere çalıştırıyorsanız, iki saniyelik fark kesinlikle ek 10 dakikalık çalışmanın haklı çıkarmayacak. Ancak ağınızdaki 500 bilgisayar için aynı betiği çalıştıracaksanız, bu küçük fark, tüm betiğin çalışmasını 15 dakika daha az sürede tamamlamanızı sağlar. Bu nedenle genel olarak zaman kazanıyorsunuz. Tabii ki, betiğinizin ne kadar hızlı olacağını ve onu daha hızlı hale getirmenin size ne kadar süre alacağını önceden bilmek oldukça zordur. Ancak genel olarak, ilk olarak okunabilir, bakımı kolay ve anlaşılır kod yazmayı amaçlarız, çünkü bu, daha az hata içeren kod yazmamıza olanak tanır. Eğer çok yavaş olan bir şey varsa, o zaman evet, onu düzeltmek mantıklıdır, özellikle betiği sıkça yürütülecekse ve hızlı yapmak, optimize etmek için harcadığınız zamandan daha fazla zaman kazandırıyorsa. Ancak unutmayın, bir betikten her saniyeyi optimize etmeye çalışmak muhtemelen zamanınıza değmez. Tamam, bu söylendi, şimdi kodumuzu nasıl daha verimli hale getirebileceğimizi inceleyelim. İlk adım, bilgisayarımızı gerçekten daha hızlı yapamayacağımızı aklımızda bulundurmaktır. Kodumuzun daha hızlı bitmesini istiyorsak, bilgisayarımızın daha az iş yapmasını sağlamamız gerekiyor ve bunu yapmak için gereksiz işleri yapmaktan kaçınmalıyız. Peki, nasıl? Yapılacak bir sürü farklı şey var. En yaygın olanlardan bazıları, daha önce hesaplanmış olan verileri saklamak, sorunu çözmek için doğru veri yapılarını kullanmak ve bilgisayarın yavaş kaynaklardan (disk veya ağ üzerinden) bilgi beklerken meşgul kalmasına izin vermek için kodu yeniden düzenlemektir. Yavaşlığın kaynaklarını belirlemek için kodumuzun çoğu zamanını nerede harcadığını anlamamız gerekiyor. Bize bu konuda yardımcı olan bir dizi araç bulunmaktadır ve bunlara profiller denir. Bir profil, kodumuzun kullandığı kaynakları ölçen, neler olduğu hakkında bize daha iyi bir anlayış sağlayan bir araçtır. Özellikle, bize belleğin nasıl tahsis edildiğini ve geçen zamanı göstermeleri nedeniyle, her bir programın hangi işlevleri çağırdığını, her işlemin ne kadar süre harcadığını göstermelerinde bize yardımcı olurlar. Profillerin nasıl çalıştığı nedeniyle, her bir programlama diline özgüdürler. Bu nedenle, bir **C** programını analiz etmek için **gprof**'u kullanırken, bir Python programını analiz etmek için **c-Profile** modülünü kullanırız. Bu tür araçları kullanarak, programımızın hangi işlevlerin çağrıldığını, her işlemin kaç kez çağrıldığını ve programın her birinin üzerinde ne kadar süre harcadığını görebiliriz. Bu şekilde, örneğin, programımızın orijinal olarak amaçladığımızdan daha fazla kez bir işlevi çağırdığını veya hızlı olmasını beklediğimiz bir işlemin aslında yavaş olduğunu görebiliriz. Kodumuzu düzeltmek için, muhtemelen pahalı eylemleri tekrarlamaktan kaçınmak için onu yeniden yapılandırmamız gerekecek. Peki pahalı ne demek? Bu bağlamda pahalı eylemler, uzun süre tamamlananlardır. Pahalı işlemler, bir dosyayı ayrıştırmak, ağ üzerinden veri okumak veya bir liste üzerinde dönmek gibi işlemleri içerir. Peki, kodumuzu pahalı işlemlerden kaçınacak şekilde nasıl değiştiririz? Bu konuda birkaç stratejiyi önümüzdeki videolarda tartışacağız.

In your role as an IT specialist or systems' administrator, you'll likely need to write scripts to automate tasks. A piece of code may start as a simple script that does a single thing, but end up growing into a complex program that handles many different tasks, and no matter the size and complexity of our code, we usually want it to perform well. In this and the next few videos, we'll discuss some ideas for how to make our code more efficient and how to figure out what needs fixing if it's slow. One important thing to keep in mind though is that we should always start by writing clear code that does what it should and only try to make it faster if we realize that it's not fast enough. If it takes you 10 minutes to write a script that will run in five seconds, and 20 minutes to write a script that will do the same but takes three seconds, does it make a difference? It all depends on how often you run the script. If you run it once a day, the two seconds deference definitely won't justify the additional 10 minutes of work. But if you're going to run the same script for the 500 computers on your network, that small difference means it will take 15 less minutes to run the whole script. So overall, you're gaining time. Of course, it's pretty hard to know in advance how fast your script will be and how long it will take you to make it faster. But as a rule, we aim first to write code that's readable, easy to maintain and easy to understand, because that lets us write code with less bugs. If there's something that's super slow, then yes, it makes sense to fix it, particularly if the script will be executed frequently enough that making it faster will save you more time than the time you spend optimizing it. But remember, trying to optimize every second out of a script is probably not worth your time. Okay, with that said, let's dive into how we can make our code more efficient. The first step is to keep in mind that we can't really make our computer go faster. If we want our code to finish faster, we need to make our computer do less work, and to do this, we'll have to avoid doing work that isn't really needed. How? There's a bunch of different things to do. The most common ones include storing data that was already calculated to avoid calculating it again using the right data structures for the problem and reorganizing the code so that the computer can stay busy while waiting for information from slow sources like disk or over the network. To know what sources of slowness we need to address, we have to figure out where our code is spending most of its time. There's a bunch of tools that can help us with that called profilers. A profiler is a tool that measures the resources that our code is using, giving us a better understanding of what's going on. In particular, they help us see how the memory is allocated and how the time spent. Because of how profilers work, they are specific to each programming language. So we would use gprof to analyze a C program but use the c-Profile module to analyze a Python program. Using tools like these, we can see which functions are called by our program, how many times each function was called and how much time are programs spent on each of them. This way we can find for example, that our program is calling a function more times than we originally intended or that a function that we thought would be fast is actually slow. To fix our code, we'll probably need to restructure it to avoid repeating expensive actions. What do we mean by expensive? In this context, expensive actions are those that take a long time to complete. Expensive operations include parsing a file, reading data over the network or iterating through a whole list. Okay. How do we modify our code to avoid expensive operations? We'll discuss a few strategies in our next videos.