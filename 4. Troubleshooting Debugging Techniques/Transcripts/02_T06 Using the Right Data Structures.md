# Using the Right Data Structures

Veri yapıları hakkında iyi bir anlayışa sahip olmak, gereksiz pahalı işlemlerden kaçınmamıza ve verimli betikler oluşturmamıza yardımcı olabilir. Özellikle, bu yapıların farklı koşullar altında performansını anlamak isteyeceğiz. Python'a giriş kursunda, Python'da bulunan çeşitli veri yapıları hakkında öğrendiniz: liste, tuple, sözlük ve küme gibi. Her birinin kullanımları, avantajları ve dezavantajları vardır. Hadi listeler ve sözlükler hakkında çok hızlı bir özet yapalım. Listeler, öğelerin sıralı koleksiyonlarıdır. Bu öğeleri ekleyebilir, kaldırabilir veya değiştirebiliriz. Her bir öğe üzerinde işlem yapmak için tüm liste üzerinde dönebiliriz. Farklı programlama dilleri bunlara farklı isimler verir. Bu yapı Java'da **ArrayList**, C++'da **Vector**, Ruby'de **Array** ve Go'da **Slice** olarak adlandırılır. Tüm bu isimler, öğelerin sonuna hızlı bir şekilde öğe eklemek veya çıkarmak için kullanılan aynı veri yapısına atıfta bulunur. Ancak ortadaki öğeleri eklemek veya çıkarmak yavaş olabilir çünkü takip eden tüm öğeler yeniden konumlandırılmalıdır. Belirli bir pozisyondaki öğeye erişmek hızlıdır, ancak bilinmeyen bir pozisyondaki bir öğeyi bulmak tüm listeyi geçmek gerektiğinden bu, liste uzunsa oldukça yavaş olabilir. Sözlükler, anahtar-değer çiftlerini depolar. Bir değeri bir anahtarla ilişkilendirerek veri ekleriz. Sonra, belirli bir anahtarı arayarak bir değeri alırız. Java'da **HashMap**, C++'da **Unordered Map**, Ruby'de **Hash** ve Go'da **Map** olarak adlandırılır. Bu isimlerdeki "map" kısmı, bir anahtar ve bir değer arasında bir eşleme oluşturduğumuzdan gelir. "Hash" kısmı, yapının verimli olması için içsel olarak bir karma fonksiyonun kullanıldığı gerçeğinden gelir. Bu yapıların temel özelliği, anahtarları hızlı bir şekilde aramak için süper hızlı olmalarıdır. Bir kez verimizi bir sözlükte depoladıysak, bir anahtarla ilişkilendirilen bir değeri bulmak sadece bir işlemle yapılabilir. Eğer bu veri bir listede depolanmışsa, listenin tamamında dolaşmamız gerekecektir. Dolayısıyla genel bir kural olarak, öğelere konumlarına göre erişmeniz veya her zaman tüm öğeleri geçmeniz gerekiyorsa, onları depolamak için bir liste kullanın. Bu örneğin, ağdaki tüm bilgisayarların, şirketteki tüm çalışanların veya şu anda satışta olan tüm ürünlerin bir listesi olabilir. Öte yandan, öğeleri bir anahtar kullanarak aramamız gerekiyorsa, bir sözlük kullanırız. Bu, bir kullanıcının kullanıcı adını kullanarak arayacağımız veri, bir bilgisayarın host adını kullanarak arayacağımız IP veya bir ürünün içsel ürün kodunu kullanarak arayacağımız veri olabilir. Birçok bu tür arama işlemi yapmamız gerekiyorsa, bir sözlük oluşturmak ve veriyi almak için kullanmak, bir listeyi geçmek yerine çok daha az zaman alacaktır. Ancak sadece bir değeri arayacaksak bir sözlük oluşturmak ve onunla doldurmak mantıklı değildir. Bu durumda, yapının oluşturulması için zaman kaybediyoruz, bunun yerine listenin üzerinde dolaşıp aradığımız öğeyi alabiliriz. Başka bir düşünmemiz gereken şey, bellekteki yapıların kopyalarını oluşturup oluşturmamak. Bu yapılar büyükse, bu kopyaları oluşturmak oldukça maliyetli olabilir. Bu nedenle, kopyanın gerçekten gerekli olup olmadığını iki kez kontrol etmeliyiz. Peki, şimdi her bir veri yapısını ne zaman kullanacağımızı ve hangi işlemlerden kaçınmamız gerektiğini daha iyi anladığımıza göre, pahalı döngülerle nasıl başa çıkacağımıza bakabiliriz. Bu, bir sonraki videomuzda sizi bekliyor.

Having a good understanding of the data structures available to us can help us avoid unnecessary expensive operations and create efficient scripts. In particular, we'll want to understand the performance of those structures under different conditions. In the introductory course to Python, you learned about a bunch of different data structures available in Python like lists, tuples, dictionaries, and sets. Each of them have their uses, their advantages, and disadvantages. Let's do a very quick recap of lists and dictionaries. Lists are sequences of elements. We can add, remove, or modify the elements in them. We can iterate through the whole list to operate on each of the elements. Different programming languages call them differently. The structure is called ArrayList in Java, Vector in C++, Array in Ruby, and Slice in Go. All these names refer to the same data structure that's fast to add or remove elements at the end. But adding or removing elements in the middle can be slow because all the elements that follow need to be repositioned. It's fast to access the element in a specific position in the list, but finding an element in an unknown position requires going through the whole list. This can be super slow if the list is long. Dictionary store key value pairs. We add data by associating a value to a key. Then, we retrieve a value by looking up a specific key. They are called HashMap in Java, Unordered Map in C++, Hash in Ruby, and Map in Go. The map part in those names comes from how we're creating a mapping between a key and a value. The Hash part comes from the fact that to make the structure efficient, a hashing function is used internally to decide how the elements will be stored. The main characteristic of this structure is that it's super-fast for looking up keys. Once we have our data stored in a dictionary, we can find the value associated to a key in just one operation. If it were stored in a list, we need to iterate through the list. So as a rule of thumb, if you need to access elements by position or will always iterate through all the elements, use a list to store them. This could be a list of all computers in the network, of all employees in the company, or of all products currently on sale for example. On the flip side, if we need to look up the elements using a key, we'll use a dictionary. This could be the data associated to a user which we'd look up using their username, the IP associated to a computer using the host name, or the data associated to a product using the internal product code. Whenever we need to do a bunch of these lookup operations, creating a dictionary and using it to get the data will take a lot less time than iterating over a list to find what we're looking for. But it doesn't make sense to create a dictionary and fill it with data if we're only going to look up one value in it. In that case, we're wasting time creating the structure when we could just iterate over the list and get the element we're looking for. Another thing that we might want to think twice about is creating copies of the structures that we have in memory. If these structures are big, it can be pretty expensive to create those copies. So we should double-check if the copy is really needed. All right. Now, that we have a better understanding of when to use each data structure and what actions to avoid, we can look into how to deal with expensive loops. That's coming up in our next video.