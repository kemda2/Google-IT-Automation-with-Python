# Expensive Loops

Döngüler, bilgisayarlarımızın işleri tekrarlayarak gerçekleştirmesini sağlayan unsurlardır. Son derece kullanışlı bir araçtır ve tekrarlayan işlerden kaçınmamıza yardımcı olur, ancak dikkatli bir şekilde kullanılmalıdır. Özellikle, döngü içinde hangi eylemleri gerçekleştireceğimizi düşünmeli ve mümkünse pahalı işlemlerden kaçınmalıyız. Eğer döngü içinde pahalı bir işlem yaparsanız, bu pahalı işlemi gerçekleştirmenin süresini döngüyü kaç kez tekrarlarsanız o kadar çoğaltırsınız. Örneğin, şirketinizdeki tüm çalışanlara acil durum iletişim bilgilerinin hala geçerli olup olmadığını doğrulamaları için bir e-posta gönderen bir betik yazıyorsanız. Bunun için her bir çalışan için bir e-posta gönderen bir döngünüz olacaktır. E-postanın içeriğinde mevcut acil durum iletişim bilgileri bulunacaktır. İlginç olan, döngü içinde verilere nasıl eriştiğinizdir. Eğer veri bir dosyada depolanıyorsa, betiğiniz bu veriyi almak için dosyayı ayrıştırmalıdır. Eğer betik her kullanıcı için her defasında tüm dosyayı okursa, dosyayı gereksiz yere sürekli ayrıştırmakla çok zaman kaybedeceksiniz. Bunun yerine dosyayı döngü dışında ayrıştırabilir, bilgileri bir sözlüğe yerleştirebilir ve ardından döngü içinde veriyi almak için sözlüğü kullanabilirsiniz. Kodunuzda bir döngü olduğunda, ne tür eylemler gerçekleştirdiğinizi kontrol ettiğinizden emin olun ve bunları sadece bir kez gerçekleştirmek için döngü dışına çıkarabileceğiniz işlemleri kontrol edin. Her bir öğe için bir ağ çağrısı yapmak yerine, döngüden önce bir kez çağrı yapın. Her bir öğe için diskten okuma yapmak yerine, döngüden önce tüm dosyayı okuyun. Döngü içinde gerçekleştirilen işlemler özellikle pahalı değilse bile, bin öğe içeren bir liste üzerinde dolaşıyorsak ve bunlardan sadece beşine ihtiyacımız varsa, ihtiyacımız olmayan öğeler üzerinde zaman kaybediyoruz demektir. Döngü içinde döndüğünüz öğeler listesinin gerçekten ne kadar uzun olması gerektiğinden emin olun. Diyelim ki içsel bir web sitesi işletiyorsunuz. Site tarafından gösterilen bilgilerin bir parçası olarak, en son beş kullanıcının oturum açma bilgisini gösterir. Kod içinde program, son başladığı zamandan bu yana oturum açan tüm kullanıcıların bir listesini tutar ve program en son beş kullanıcıyı göstermek istediğinde, tüm listeyi geçer ve bunlardan en son beşi hangileriyse bulur. Bu çok zaman kaybına neden olabilir. Servis bir süredir çalışıyorsa, tüm liste üzerinden geçmek gerçekten uzun sürebilir. Bunun yerine, servisi değiştirip kullanıcı erişim bilgilerini gerektiğinde okunabilen log dosyalarında saklamak ve sadece son beş oturumu bellekte tutmak daha verimli olabilir. Yeni bir kullanıcı oturum açtığında, liste içindeki en eski giriş atılır ve yeni bir tane eklenir. Bu şekilde, betik her en son beş kullanıcıyı göstermesi gerektiğinde her seferinde tüm listeyi geçmek zorunda kalmaz. Döngülerle ilgili hatırlanması gereken bir başka şey de aradığınızı bulduktan sonra döngüden çıkmaktır. Python'da bunu "break" anahtar kelimesiyle yaparız. Döngülerden çıkmak, aradığımız veri bulunduğunda betiğimizin devam edebilmesi anlamına gelir. Elbette, veri listede en sona yerleştirilmişse, o zaman yine de döngüden geçmemiz gerekecek. Ancak veri listenin başında ve sonunda değilse, kodumuzun betiği hızlandırmak için erken çıkmasının mantıklı olacaktır. Diyelim ki belirli bir kullanıcı adının yetkilendirilmiş varlıklar listesinde olup olmadığını kontrol eden bir betik yazıyorsunuz ve eğer öyleyse, belirli bir kaynağa erişim izni veriyor. Varlıklar listesini geçmek için bir for döngüsünü kullanabilirsiniz. Kullanıcı adı bulunduğunda döngüden çıkabilir ve betiğin geri kalanına devam edebilirsiniz. Unutulmaması gereken son bir şey, bir sorun için doğru çözümün başka bir sorun için doğru olmayabileceğidir. Diyelim ki servisinizin toplamda 20 kullanıcısı var. Bu durumda, bir şeyi kontrol etmek istediğinizde listenin üzerinden geçmek sorun değildir. Bu kadar kısa bir liste, özel bir optimizasyona ihtiyaç duyulmadan yeterlidir. Ancak servisiniz binlerce kullanıcıya sahipse, bu listeden geçmek mümkünse kaçınılması gereken bir durumdur. Eğer servisiniz yüz binlerce kullanıcıya sahipse, bu listeden geçmek zaten bir olasılık değildir. Bir sonraki adımda, pahalı işlemler döngülerimizin dışında olduğunda ne yapabileceğimizi konuşacağız.

Loops are what make our computers do things repeatedly. They are an extremely useful tool and let us avoid repetitive work, but we need to use them with caution. In particular, we need to think about what actions we're going to do inside the loop, and when possible, avoid doing expensive actions. If you do an expensive operation inside a loop, you multiply the time it takes to do the expensive operation by the amount of times you repeat the loop. Say for example that you're writing a script to send an email to all the employees at your company asking them to verify that their emergency contact information is still valid. To send this out, you'll have a loop that sends one email per employee. In the body of the email, you'll include the current emergency contact data. The interesting part is how you access the data inside the loop. If the data is stored in a file, your script will need to parse the file to fetch it. If the script reads the whole file for every user, you'll be wasting a lot of time parsing the file over and over unnecessarily. Instead, you could parse the file outside of the loop, put the information into a dictionary, and then use the dictionary to retrieve the data inside the loop. Whenever you have a loop in your code, make sure to check what actions you're doing, and see if there are operations you can take out of the loop to do them just once. Instead of making one network call for each element, make one call before the loop. Instead of reading from disk for each element, read the whole thing before the loop. Even if the operations done inside the loop aren't especially expensive, if we're going through a list of a thousand elements and we only need five out of them, we're wasting time on elements we don't need. Make sure that the list of elements that you're iterating through is only as long as you really need it to be. Let's say you're running an internal website. As part of the information the site shows, it displays a list of the last five users that logged in. In the code, the program keeps a list of all the users that have logged in since it last started, and when the program needs to display the five latest users, it goes through the whole list and finds out which of those are the five most recent. This wastes a lot of time. If the service has been running for a while, it can take really long to go through the whole list. Instead, you could modify the service to store the user access info in log files that can be read if necessary and only keep the last five logins in memory. Whenever a new user logs in, the oldest entry in the list gets discarded and a new one gets added. That way, the script doesn't need to go through the whole list every time it needs to display the five most recent users. Another thing to remember about loops is to break out of the loop once you found what you were looking for. In Python, we do this using the keyword break. Breaking out of loops means that as soon as the data we're looking for is found, our script can continue. Of course if the data is at the end of the list, then we need to go through the loop anyway. But when the data is at the beginning of the list and not at the end, it makes sense to have our code break early to make the script faster. Say you're writing a script that checks if a given username is within the list of authorized entities, and if it is, it grants them access to a particular resource. You can use a for loop to iterate through the list of entities. When the username is found, you can break out of the loop and continue the rest of the script. One last thing to keep in mind is that the right solution for one problem might not be right for a different problem. Say your service has a total of 20 users. In that case, it's okay to go over this list whenever you want to check something. It's short enough that you don't need to do any special optimization. But if your service has over a thousand users, you'll want to avoid going through that list unless absolutely necessary. If the service has hundreds of thousands of users, going through that list isn't even a possibility. Up next, we'll talk about what we can do when the expensive operations are already outside of our loops