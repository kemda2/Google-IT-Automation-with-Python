# Keeping Local Results

Son videomuzda, döngülerimiz içinde pahalı işlemlerden kaçınmanın yollarını konuştuk. Yani bir dosyayı ayrıştırmamız gerekiyorsa, bunu döngüyü çağırmadan önce bir kez yaparız, döngünün her elemanı için tekrar etmek yerine. Ancak dosyanın ayrıştırılması döngü dışında yapıldığında bile çok zaman alıyorsa ne olacak? Betimlemiştik ki betiklerimizin hedefine daha hızlı ulaşabilmesi için bilgisayarımızın gereksiz işler yapmasından kaçınmalıyız. Peki, bir dosyayı ayrıştırmak, ağ üzerinden veri indirmek veya uzun bir listeden geçmek gibi pahalı işlemleri nasıl kaçınabiliriz? Betik düzenli olarak çalıştırılıyorsa, yerel bir önbellek oluşturmak yaygındır. Daha önceki bir videoda önbelleğin, verileri orijinal formundan daha hızlı erişilebilecek bir biçimde depolama şekli olduğunu söylemiştik. Bu nedenle, büyük bir dosyayı ayrıştırıyorsak ve ondan sadece birkaç anahtar bilgiyi tutuyorsak, yalnızca bu bilgileri depolamak için bir önbellek oluşturabiliriz. Ya da ağı üzerinden bazı bilgiler alıyorsak, dosyanın sürekli indirilmesini önlemek için dosyanın yerel bir kopyasını tutabiliriz. Önbellek oluşturmak, zaman kazanmak ve programlarımızı daha hızlı yapmak için son derece yararlı olabilir. Ancak bazen doğru yapmak zor olabilir. Önbelleği ne sıklıkta güncelleyeceğimizi ve önbellekteki verilerin güncellenmemişse ne olacağını düşünmemiz gerekiyor. Eğer uzun vadeli istatistiklere bakıyorsak, önbelleği günde bir kez oluşturabilir ve bu bir sorun olmayacaktır. Bu, örneğin son bir ay içinde filo genelinde bilgisayarların ne kadar bellek kullandığını, bir şirketin her bölümündeki çalışan sayısını veya son çeyrekte her üründen kaç birim satıldığını içeren veriler için geçerli olabilir. Ancak şu anda önemli olan bir veriye bakmaya çalışıyorsak, önbelleği kullanamayız veya çok kısa ömürlü olmalıdır. Bu durum, bilgisayar sağlığını izlemek için bir önbelleği kullanmak veya bir ürünü satmak için yeterince ürün olup olmadığını görmek veya yeni bir tane oluştururken ağda bir kullanıcı adının zaten var olup olmadığını kontrol etmek için geçerli olabilir. Bazen, önbelleği yeniden hesaplamamız gerekip gerekmediğini doğrulamak için bir kontrol ekleyebiliriz. Örneğin, önbelleğimiz bir dosyaya dayanıyorsa, önbelleği hesapladığımızda dosyanın değiştirilme tarihini saklayabiliriz. Ardından, önbelleği yalnızca dosyanın değiştirilme tarihi sakladığımız tarihten daha yeni ise yeniden hesaplarız. Eğer önbelleğimizin güncel olup olmadığını kontrol etme yöntemimiz yoksa, programımıza mantıklı bir karar vermeye çalışan mantık eklememiz gerekecek. Bunun için verilerin ne sıklıkta değişmesini beklediğimizi, en son verinin kullanılmasının ne kadar önemli olduğunu ve çalıştırdığımız programın ne sıklıkta çalıştığını düşüneceğiz. Tüm bu faktörleri göz önüne aldıktan sonra, önbelleğin günde bir kez, saatte bir kez veya hatta dakikada bir kez oluşturulması gerektiğine karar verebiliriz. Evet, dakikada bir kez bile mantıklı olabilir, eğer betiğiniz dakikada birkaç kez çalıştırılabilen ve önbelleği kullanarak önbelleğe alınabilecek pahalı bir işlemi yapması gerekiyorsa. Bu şekilde, bir dakikadaki sadece ilk yürütme bu işlem için zaman harcayacak, gerisi çok hızlı olacaktır. Ancak önbellek asla bir dakikadan daha eski olmayacaktır. Unutmayın ki önbellekler her zaman karmaşık zaman aşımı mantığı ve çok bilgi depolayan karmaşık yapılar olmak zorunda değildir. Bazı durumlarda, bu bilgiyi her seferinde yeniden hesaplamak yerine geçici bir sonucu depolayan bir değişken olması kadar basit olabilir. Örneğin, ağdaki farklı gruplardaki kullanıcı sayısını yazdıran bir rapor oluşturuyorsanız. Şimdi, bu grupların bazıları içerdikleri diğer grupları içerebilir ve bazı gruplar hatta birkaç grupta bulunabilir. Örneğin, Java sürüm mühendisleri grubu, sürüm mühendisleri grubunun ve Java geliştiriciler grubunun bir parçası olacaktır. Eğer aynı kullanıcılar birden çok grupta görünüyorsa, bunları birden çok saymaktan nasıl kaçınabiliriz? Grubu anahtar ve kullanıcı sayısını değer olarak içeren bir sözlüğümüz olabilir. Bu şekilde bir grup üyelerini sadece bir kez saymamız ve sonra sözlükteki değeri kullanmamız yeterlidir. Tüm bunları özetlemek gerekirse, pahalı işlemleri yapmaktan kaçınmanıza izin verecek stratejiler aramak isteyeceksiniz. İlk olarak, bu işlemlerin hiç gerekli olup olmadığını kontrol edin. Eğer gerekliyse, pahalı işlemi gereğinden fazla tekrarlamamak için ara sonuçları depolayabilir misiniz bakın. Bir sonraki aşamada, beklenenden daha yavaş çalışan bir kodla başa çıkmanın pratik bir örneğine bakacağız.

In our last video, we talked about how to avoid having expensive operations inside our loops. So if we have to parse a file, we do it once before we call the loop instead of doing it for each element of the loop. But what if parsing the file is taking a lot of time even when it's done outside of the loop? Remember that to make our scripts get to their goal faster, we need to avoid having our computer do unnecessary work. So how can we avoid expensive operations like parsing a file, downloading data over the network, or going through a long list? If the script gets executed fairly regularly, it's common to create a local cache. In an earlier video, we said that a cache is a way of storing data in a form that's faster to access than its original form. So if we're parsing a large file and only keeping a few key pieces of information from it, we can create a cache to store only that information, or if we're getting some information over the network, we can keep a local copy of the file to avoid downloading it over and over again. Creating caches can be super useful to save us time and make our programs faster. But they're sometimes tricky to get right. We need to think about how often we're going to update the cache and what happens if the data in the cache is out of date. If we're looking for some long-term stats, we can generate the cache once per day, and it won't be a problem. This might be the case for data like how much memory was used on computers across the fleet over the last month? How many employees each department in a company has? Or how many units were sold of each product over the last quarter? But if we're trying to look at data where the value as of right now is super important, we either can't use a cache or it has to be very short-lived. This could be the case for monitoring the health of computers to alert when something crosses a threshold. Checking the stock levels to see if there's enough of a product to sell or seeing if a username already exists in the network when trying to create a new one. Sometimes, we can add a check to validate if we need to recalculate the cache or not. For example, if our cache is based on a file, we could store the modification date of that file when we calculated the cache. Then only recalculate the cache if the modification date of the file is newer than the one we had stored. If we don't have a way of checking if our cache is out of date or not, we'll need to add in logic to our program that tries to make a sensible decision. For that, we'll take into account how often we expect the data to change, how critical it is that the latest data is used, and how frequently the program that we're running will be executed. After taking all these factors into account, we might decide that the cache needs to be recreated once per day, once per hour, or even once per minute. Yes, even once per minute might make sense if you have a script that can get executed several times per minute and needs to do an expensive operation that can be cached. That way, only the first execution in a minute will spend time on this operation, the rest will be very fast. But the cache is never more than a minute out of date. Keep in mind that caches don't always need to be elaborate structures, storing lots of information with a complex timeout logic. Sometimes, they can be as simple as having a variable that stores a temporary result instead of calculating this result every time we need it. For example, say you're generating a report that prints how many users there are in each of the different groups in the network. Now, some of these groups may contain other groups in them and some groups may even be part of several groups. For example, the Java release engineers group would be part of the release engineers group and the Java developers group. How can we avoid counting unique users more than once if they show up in multiple groups? We can have a dictionary with the group as the key and the amount of users as the value. That way, we only need to count the members of a group once, and after that, just use the value in the dictionary. To sum all of this up, remember that you'll want to look for strategies that let you avoid doing expensive operations. First, check if these operations are needed at all. If they are, see if you can store the intermediate results to avoid repeating the expensive operation more than needed. Up next, we'll look into a practical example of how to deal with some code that's running slower than expected.