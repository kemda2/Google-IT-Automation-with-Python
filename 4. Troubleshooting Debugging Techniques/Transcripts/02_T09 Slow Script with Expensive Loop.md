# Slow Script with Expensive Loop

Tarihlerle sorun yaşayan toplantı hatırlatıcı betiğini hatırlıyor musun? Geliştiriciler üzerinde çalışmayı sürdürdü. Şimdi, kişiselleştirilmiş e-postalarla, e-posta alan kişinin adı ve selam içeriyor. Bu güzel. Ancak maalesef uygulamayı oldukça yavaş hale getirdi gibi görünüyor. Geliştiriciler, programı nasıl daha hızlı yapabileceğimizi bulmamız için yardım istiyorlar. O zaman hemen işe koyulalım. İlk olarak, sorunu yeniden üretmemiz ve bu durumda yavaşın ne anlama geldiğini anlamamız gerekecek. Bir kullanıcı bize, alıcı listesi uzun olduğunda sorunun görüldüğünü söyledi. Bu konuyu test ederken meslektaşlarımıza spam yapmamak için, mail sunucumuzda oluşturduğumuz bir grup test kullanıcısına hatırlatıcılar göndereceğiz. Uygulamanın iki bölümden oluştuğunu hatırlayabilirsin. Bir pencere çıkaran kabuk betiği, hatırlatıcı verilerini girebileceğimiz ve bir Python betiği, e-postayı hazırlayan ve gönderen. Yavaş olan kısım e-postaların gönderilmesi. Bu nedenle hiçbir şekilde pencere ile etkileşimde bulunmayacağız. Sadece ihtiyacımız olan parametreleri Python betiğine ileteceğiz. Betiği zaman komutunu kullanarak hızını ölçeceğiz. İlk olarak sadece bir test kullanıcısı ile çağıralım ve ne kadar sürdüğünü görelim. Zamanı çağırdığımızda, ona geçtiğimiz komutu çalıştırır ve onu yürütmek için ne kadar zaman aldığını yazdırır. Üç farklı değer var. Gerçek, kullanıcı ve sistem. Gerçek, komutun çalıştırılması için ne kadar gerçek zaman aldığını belirtir. Bu değere bazen duvar saat zamanı denir çünkü bilgisayarın ne yaparsa yapsın, bir duvara asılı saat ne kadar süre ölçer. Kullanıcı, kullanıcı alanında yapılan işlemlerde harcanan zamandır. Sistem, sistem seviyesindeki işlemlerde harcanan zamandır. Kullanıcı ve sistem değerlerinin gerçek değerine eşit olması gerekmez çünkü bilgisayar başka işlerle meşgul olabilir. Peki, burada ne görüyoruz? Betiğimizin bir e-postayı göndermek için 0.129 saniye sürdü. Bu çok değil, ancak mesajı yalnızca bir kullanıcıya gönderiyoruz. Şimdi bunu dokuz test kullanıcısı ile tekrar deneyelim. İki, üç, dört, beş, altı, yedi, sekiz, dokuz. Tamam. Bu sefer e-postayı göndermek için 0.296 saniye sürdüğünü görüyoruz. Hala çok değil, ancak daha uzun bir e-posta listesi ile daha uzun sürdüğü görünüyor. Peki, şimdi bunu daha iyi hale getirmeye çalışma zamanı. Kodla neyin yanlış olduğunu nasıl bulabiliriz? Her zaman kodu inceleyebilir ve iyileştirebileceğimiz pahalı işlemleri bulup bulamayacağımıza bakabiliriz. Ancak bu durumda, neyin yanlış gittiği hakkında bazı verilere ulaşmak için bir profil kullanmak istiyoruz. Bu yüzden bunu deneyelim. Python için farklı kullanım durumları için farklı profiller bulunmaktadır. Burada, **pprofile 3** adlı bir tane kullanacağız. Ona **call grind** dosya formatını kullanması için -f bayrağını, çıktıyı profile.out dosyasına kaydetmesi için de -o bayrağını kullanıyoruz. Bu, call grind formatını destekleyen herhangi bir araçla açabileceğimiz bir dosya oluşturur. Bu dosyayı incelemek için kcachegrind kullanacağız, bu da bu dosyalara bakmak için bir grafik arayüzüdür. Bu programla ilgili birçok şey olduğu için, bunun anlamak biraz zaman alıyorsa korkmayın. Birçok diğer şeyde olduğu gibi, kendi başınıza pratik yapmak ve kurcalamak, buradaki tüm farklı şeylere alışmanıza yardımcı olacaktır. Şimdi ihtiyacımız olan bilgilere bakalım. Sağ alt yarıda bir çağrı grafiği görüyoruz, bu da ana fonksiyonun send message fonksiyonunu bir kez çağırdığını söylüyor. Bu fonksiyon, message template fonksiyonunu, get name fonksiyonunu ve send message fonksiyonunu her birini dokuz kez çağırıyor. Grafik aynı zamanda bu çağrıların her birinde kaç mikrosaniye harcandığını da söylüyor. Çoğu zamanın get name fonksiyonunda harcandığını görebiliriz. Bu muhtemelen optimize etmemiz gereken fonksiyon. Bu fonksiyonun ne yaptığına bakalım. Atom kullanarak bu fonksiyonun ne yaptığını görebiliriz. Bu fonksiyonun bir CSV dosyasını açtığını, ardından tüm dosyayı kontrol ederek satırdaki ilk alanın e-posta adıyla eşleşip eşleşmediğini kontrol ettiğini ve bu durumda isim değişkeninin değerini ayarladığını görebiliriz. Bu fonksiyonda yanlış olan birkaç şey var. İlk olarak, liste içindeki öğeyi bulduktan sonra döngüden hemen çıkmalı. Şu anda, e-posta ilk satırda bulunsa bile tüm dosyayı üzerinden geçiyor. Ancak bunu düzeltsek bile, hala dosyayı her e-posta adresi için açar ve üzerinden okurdu. Bu, dosyanın çok fazla satır içeriyorsa gerçekten yavaş olabilir. Peki, bunu nasıl daha iyi hale getirebiliriz? Dosyayı bir kez okuyabilir ve bizi ilgilendiren değerleri bir sözlükte depolayabilir ve ardından bu sözlüğü aramalar için kullanabiliriz. Hadi yapalım. get name fonksiyonunu değiştirecek ve CSV dosyasını işleyecek bir read names fonksiyonuna dönüştüreceğiz ve istediğimiz değerleri names sözlüğüne depolayacak. Her satır için e-postayı anahtar olarak ve isimleri değer olarak depolayacağız. Bir isim döndürmek yerine tüm sözlüğü döndüreceğiz. Tamam, istediğimiz verileri bir sözlükte depolayan bir read names fonksiyonumuz var. Şimdi bunun send message fonksiyonundaki çağrı şeklini değiştirmemiz gerekiyor. get name fonksiyonunun her bir e-posta için bir kez çağrıldığını görüyoruz. Değişikliğimizi uygulamak için read names fonksiyonunu for döngüsünden önce çağırmalıyız, böylece bunu sadece bir kez yaparız. Sonra get name'i çağırmak yerine değerleri sadece sözlükten alırız. Tamam, değişikliği yaptık. Dosyamızı kaydedelim ve betiğimizi tekrar profilleyelim, eğer daha hızlı hale getirebildiysek görelim. Grafiği şimdi değiştirdik çünkü kodun davranışını değiştirdik. read names fonksiyonunun şimdi çok daha küçük bir süre aldığını görebilirsiniz. Öte yandan, şimdi en çok zaman alanın message template olduğunu görüyoruz. Yani betiğimizi daha da hızlı yapmaya devam etmek istiyorsak, ona bakmalıyız. Bu videoda, bir programın ne kadar sürede çalıştığını kontrol etmek için time komutunu kullanabileceğimizi gördük. Sonra bir profil ve profil görselleştiriciyi birleştirerek kodumuzun çoğunlukla hangi bölgede zaman harcadığını anlamak için nasıl kullanabileceğimizi gördük. Son olarak, bilgiyi bir sözlükte depolayarak ve ardından sözlüğe erişerek tekrar tekrar pahalı döngülerden kaçınmak için kodumuzu değiştirdik. Şimdi sıradaki adımda, profil oluşturma hakkında daha fazla bilgi içeren bir okuma var ve ardından her şeyin hala anlamlı olup olmadığını kontrol etmek için bir uygulama sınavı bulunuyor.

Remember that meeting reminder script that was having trouble with the dates? The developers has kept working on it. Now, since personalized emails with the name of the person getting email and the greeting. That's cool. But unfortunately it seems to have made the application pretty slow. The developers are asking for our help in figuring out how we can make the program faster. So let's get to work. First, we'll need to reproduce the problem and figure out what slow means in this case. One user told us that the problem is visible when the list of recipients is long. To avoid spamming our colleagues while we're testing this issue, we'll send reminders to a bunch of test users that we've created in our mail server. You might remember that the application has two parts. A shell script that pops up a window where we can enter the data of the reminder and a Python script that prepares the email and sends it. The part that's slow is the sending of the emails. So we won't interact with the pop-up at all. We'll just pass the parameters we need to the Python script. We'll measure the script speed using the time command. Let's first call it with just one test user and see how long it takes. When we call time it runs the command that we pass to it and prints how long it took to execute it. There's three different values. Real, user, and sys. Real is the amount of actual time that it took to execute the command. This value is sometimes called wall-clock time because it's how much time a clock hanging on the wall would measure no matter what the computer's doing. User is the time spent doing operations in the user space. Sys is the time spent doing system level operations. The values of user and sys won't necessarily add up to the value of real because the computer might be busy with other processes. Okay. What do we see here? It took our script 0.129 seconds to send the email. That's not a lot but we only send the message to one user. Let's try this again with our nine tests users. Two test three, test four, test five, test six, test seven, test eight, test nine. All right. We see that it took 0.296 seconds to send the email this time. That's still not a lot but it does look like it's taking longer with a longer list of emails. Okay. It's time to try to make this better. How can we find out what's wrong with the code? We could always look at the code and see if we find any expensive operations that we can improve. But in this case we want to use a profiler to get some data about what's going on. So let's try that. There's a bunch of different profilers available for Python that work for different use cases. Here, we'll use the one called pprofile 3. We use the dash f flag to tell it to use the call grind file format and the dash o flag to tell it to store the output in the profile dot out file. This generated a file that we can open with any tool that supports the call grand format. We're going to use kcachegrind to look at the contents, which is a graphical interface for looking into these files. There's a lot going on with this program. So don't get scared if it takes a while to make sense out of it. As with so many other things practicing and tinkering on your own will help you get used to what all the different things here mean. Let's look at the information we need now. In the lower right half we see a call graph, which tells us that the main function is calling the send message function one time. This function is calling the message template function, the get name function, and the send message function nine times each. The graph also tells us how many microseconds are spent on each of these calls. We can see that most of the time is being spent in the get name function. That's probably the one we should optimize. Let's see what this function is doing using atom. So we see that the get name function opens a CSV file then goes through the whole file checking if the first field in the line matches the e-mail name and when that's the case it sets the value of the name variable. There's a couple of things that are wrong with this function. First, once it finds the element in the list it should immediately break out of the loop. Right now, it's iterating through the whole file even if the email was found in the first line. But even if we fixed that it would still open the file and read through it for each e-mail address. This can get really slow if the file has a lot of lines. So how can we make this better? We can read the file once and store the values that we care about in a dictionary and then use that dictionary for the lookups. Let's do that. We'll change the get name function and turn it into a read names function that will process the CSV file and store the values we want in the names dictionary. For each line will store the email as the key and the names as the values. Instead of returning one name we'll return the whole dictionary. All right we have a read names function that stores the data we want in a dictionary. We now need to change the way this is called in the send message function. We see that the get name function is being called once per email. To apply our change we should call the read names function before the for loop so that we do it only once. Then instead of calling get name we'll just get the values form the dictionary. All right we've made the change. Let's save our file and profile our script again to see if we manage to make it any faster. The graph looks different now as we've changed how the code behaves. See how the read names function is now taking a much smaller portion of time. On the flip side we see that the message template is the one that's taking the most time now. So if we wanted to keep making our script faster that's what we look next. In this video, we saw that we can use the time command to check how long it takes to execute a program. We then saw how we can combine a profiler and a profile visualizer to figure out where our code is spending most of his time. Finally, we changed our code to avoid doing inexpensive loop over and over by storing the information in a dictionary and then accessing the dictionary instead. Up next there's a reading with more information about profiling and after that a practice quiz to check if this is all still making sense.