# Using Threads to Make Things Go Faster

[MÜZİK] Şirketimizin e-ticaret websitesinde satışa sunulan ürünlerin birçok görüntüsü bulunmaktadır. Yaklaşan bir marka değişikliği var, bu da tüm bu görüntülerin yeni olanlarla değiştirilmesi gerektiği anlamına geliyor. Bu hem tam boyutlu görüntüler hem de küçük resimleri içerir. Tam boyutlu görüntülerden küçük resimleri oluşturan bir betiğimiz var. Ancak işlenecek çok fazla dosya var ve betiğimizin tamamlanması uzun sürecek gibi görünüyor. İşleri bir üst seviyeye taşımanın ve yeniden boyutlandırmak için daha iyi bir şey kullanmanın zamanı geldi gibi görünüyor. Şu anda 1.000 test görüntüsü kümesini kullanarak mevcut betiği olduğu gibi deneyerek başlayacağız. Dönüştürülecek daha fazla görüntü var, ancak betiğimizin hızını daha küçük bir grupla test etmek daha kolay olacak. Programımızı ne kadar sürede tamamladığını görmek için zaman komutunu kullanarak betiğimizi yürüteceğiz. 1.000 görüntü için yaklaşık iki saniye sürdü. Bu çok yavaş görünmüyor, ancak dönüştürülmesi gereken on binlerce görüntü var ve sürecin mümkün olduğunca hızlı olmasını istiyoruz. İşleri daha hızlı yapmak için bunu paralel olarak işleterek deneyelim. Öncelikle, Python thread'lerinin bir parçası olan futures alt modülünü içe aktararak başlayacağız. Bu, Python thread'lerini kullanmanın çok basit bir yolunu bize sağlar. Paralel olarak işlem yapabilmek için bir yürütücü oluşturmanız gerekecek. Bu, işi farklı işçiler arasında dağıtan süreçtir. **Futures** modülü, thread'leri kullanmak için birkaç farklı yürütücü sağlar. Şimdilik **ThreadPoolExecutor**'ı kullanacağız. Şimdi bu döngüde çoğu işi yapan işlev process_file. Doğrudan döngüde çağırmak yerine, yürütücüye işlevin adını ve parametrelerini içeren yeni bir görev göndeririz. Artık for döngümüz, yürütücüde planlanmış bir dizi görev oluşturur. Yürütücü, onları thread'leri kullanarak paralel olarak çalıştıracak. Thread'leri kullandığımızda meydana gelen ilginç bir şey, döngünün tüm görevler planlandığında bitmesidir. Ancak görevlerin tamamlanması biraz zaman alacaktır. Bu yüzden tüm thread'lerin tamamlanmasını beklediğimizi belirten bir mesaj ekleyeceğiz ve ardından yürütücü üzerinde kapatma işlevini çağıracak şekilde düzenleyeceğiz. Bu işlev, havuzdaki tüm işçilerin işlerini bitene kadar bekler ve yürütücüyü ancak o zaman kapatır. Peki, değişiklik yaptık, şimdi betiğimizi kaydedelim ve test edelim. Betiğimiz şimdi 1,2 saniye sürüyor. Bu, önce gördüğümüz iki saniyeye kıyasla güzel bir iyileşmedir. Kullanıcı zamanının gerçek zamanından daha yüksek olduğuna dikkat ettiniz mi? Birden çok thread kullanarak, betiğimiz bilgisayardaki farklı işlemcilerden yararlanıyor. Ve bu değer, tüm işlemcilerin kullanılan zamanını gösterir. İplikler yerine işlemleri kullanmaya çalışırsak ne olacağını düşünüyorsunuz? İpliklerin yerine işlemleri kullanarak bunu deneyelim. Kullandığımız yürütücüyü değiştirerek bunu deneyelim. Yürütücüyü **ProcessPoolExecutor** olarak değiştirerek, paralel işlemler için iplikler yerine işlemleri kullanmak istediğimizi futures modülüne bildiriyoruz. Şimdi bunu kaydedip deneyelim. Vay be, şimdi bu sadece bir saniyeden az bir sürede tamamlanıyor ve kullanıcı zamanı daha da arttı. Çünkü işlemleri kullanarak, CPU'yu daha fazla kullanıyoruz. Fark, Python'da ipliklerin ve işlemlerin nasıl çalıştığından kaynaklanır. Threads, aynı değişkene yazmaya çalışan iki Thread'i önlemek için bir dizi güvenlik özelliği kullanır. Ve bu, iplikleri kullanırken, birkaç milisaniye boyunca değişkenlere yazma sırasını bekleyebilirler, bu da iki yaklaşım arasındaki küçük farka eklenir. Bu videoda, bir Python betiğine iplik desteği ekleyerek işlemci gücümüzü daha iyi kullanmanın nasıl yapılabileceğine baktık. Betiğimizi kontrol etmek ve dönüşüm yapmadan önce küçük resmin var olup olmadığını ve güncel olup olmadığını kontrol etmek gibi daha fazla iyileştirme yapabileceğimiz alanlar var. Veya görevlerin tamamlanmasını beklerken ikinci bir ilerleme çubuğu eklemek gibi, betiğimizin işini yaptığını açıkça göstermek için. Bunlara burada girmeyeceğiz, ancak ilgileniyorsanız, bu olanakları kendi başınıza keşfedebilirsiniz. Bir sonraki okuma, daha fazla bilgiye işaret eden ipuçlarıyla, modülün son alıştırma sınavıyla devam edecek.

[MUSIC] Our company has an e-commerce website that includes a bunch of images of the products that are up for sale. There's a rebranding coming up, which means that all of these images will need to be replaced with new ones. This includes both the full-size images and the thumbnails. We have a script that creates the thumbnails based on the full-size images. But there's a lot of files to process, and our script is taking a long time to finish. It looks like it's time to take it up a notch and use something better to do the resizing. We'll start by trying out the current script as-is using a set of 1,000 test images. There's more images to convert, but it'll be easier to test the speed of our script with a smaller batch. We'll execute our program using the time command to see how long it takes. It took about two seconds for 1,000 images. This doesn't seem too slow, but there's tens of thousands of images that need converting, and we want to make sure that the process is as fast as possible. Let's try making this go faster by having it process the images in parallel. We'll start by importing the futures sub module, which is part of the concurrent module. This gives us a very simple way of using Python threads. To be able to run things in parallel, we'll need to create an executor. This is the process that's in charge of distributing the work among the different workers. The futures module provides a couple of different executors, one for using threads and another for using processes. We'll go with the ThreadPoolExecutor for now. Now the function that does most of the work in this loop is process_file. Instead of calling it directly in the loop, we'll submit a new task to the executor with the name of the function and its parameters. Our for loop now creates a bunch of tasks that are all scheduled in the executor. The executor will run them in parallel using threads. An interesting thing that happens when we use threads is that the loop will finish as soon as all tasks are scheduled. But it will still take a while until the tasks complete. So we'll add a message saying that we're waiting for all threads to finish, and then call the shutdown function on the executor. This function waits until all the workers in the pool are done, and only then shuts down the executor. All right, we've made the change, let's save our script and test it out. Our script now takes 1.2 seconds. That's a nice improvement over the two seconds we saw before. See how the user time is higher than the real time? By using multiple threads, our script is making use of the different processors available in the computer. And this value shows the time used on all processors combined. What do you think will happen if we try to use processes instead of threads? Let's try this out by changing the executor that we're using. By changing the executor to the ProcessPoolExecutor, we tell the futures module that we want to use processes instead of threads for the parallel operations. Let's save and try this one out now. Wow, this is now taking less than a second to finish, and the user time has gone up even more. This is because, by using processes, we're making even more use of the CPU. The difference is caused by the way threads and processes work in Python. Threads use a bunch of safety features to avoid having two threads that try to write to the same variable. And this means that when using threads, they may end up waiting for their turn to write to variables for a few milliseconds, adding up to the small difference between the two approaches. In this video, we looked into how we can add threading support to a Python script to make better use of our processor power. There's still more improvements that we can make to our script, like checking if the thumbnail exists and is up to date before doing the conversion. Or adding a second progress bar while waiting for tasks to finish, to make it clear that our script is doing its job. We won't go into those here, but if you're interested, you can explore those possibilities on your own. Up next, another reading with pointers to more information, followed by the last practice quiz of the module.