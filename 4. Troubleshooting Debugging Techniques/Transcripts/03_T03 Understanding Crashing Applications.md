# Understanding Crashing Applications

Bir uygulama çöktüğünde ve nedenini bilmiyorsak, başarısızlıkla ilgili olabilecek kayıtları aramak isteyeceğiz. Linux'ta kayıtlara bakmak için **sistem log** dosyalarını, **VAR log** veya **kullanıcı log** dosyalarını ve **nokta erişim hataları** dosyasını açarız. Mac OS'ta genellikle logları incelemek için **console** uygulamasını, Windows'ta ise **Event Viewer**'ı kullanırız. Peki, bu loglarda hangi verilere bakmalısınız? Çoğu logun her satırı için bir tarih ve saat bulunur. Uygulama çöktüğünde bu zaman etrafında bir log satırı arayarak, çöken uygulamaya ilişkin bir hata mesajını bulmaya çalışabilirsiniz. Hatalar bazen izin reddedildi, böyle bir dosya veya dizin yok, bağlantı reddedildi gibi açıklayıcı olabilir. Bazen kriptik bir mesaj olabilir ve ne anlama geldiğini bilmezsiniz. Ancak her ne olursa olsun, hata mesajımızı ne kadar garip olursa olsun, çevrimiçi arayarak anlamaya çalışabiliriz. Şanslıysak, hatanın ne anlama geldiğini ve ne yapabileceğimizi resmi belgelerde bulabiliriz. Ancak bu mümkün değilse, genellikle benzer bir hatayla karşılaşan diğer kişilerin yazılarını buluruz ve bu ek bilgiler bize neyin olduğunu anlamamıza yardımcı olabilir. Eğer hata yoksa veya hatalar yararlı değilse, **sling debug logging**'i etkinleştirerek daha fazla bilgi edinmeye çalışabiliriz. Birçok uygulama, hata ayıklama günlüğü etkinleştirildiğinde daha fazla çıktı üretir. Bunu etkinleştirmek için uygulamanın yapılandırma dosyasındaki bir ayarı veya uygulamayı manuel olarak çalıştırırken geçirilecek bir komut satırı parametresini etkinleştirmemiz gerekebilir. Bu ekstra günlükleme bilgisi etkinleştirildiğinde, sorunu gerçekten neyin tetiklediği konusunda daha iyi bir fikir edinebiliriz.Eğer hiç log veya hata mesajı yoksa ne yapmalıyız? Bu durumda, programın içinde neler olduğunu görmemizi sağlayan araçları kullanmamız gerekecek. Linux'te **S Trace** kullanarak bir programın hangi sistem çağrılarını yaptığını görebiliriz. Mac OS'ta karşılık gelen araç de **trois**'dir ve Windows'ta işlemin içinde neler olduğuna bir göz atabilir olan **Process Monitor**'dir. Bir programın hangi sistem çağrılarını yaptığını izleyerek, hangi dosyaları ve dizinleri açmaya çalıştığını, hangi ağ bağlantılarını kurmaya çalıştığını ve hangi bilgileri okumaya veya yazmaya çalıştığını görebiliriz. Bu, gerçek soruna neyin neden olduğu konusunda bize daha iyi bir fikir verebilir.Eğer uygulama önceden düzgün çalışıyorsa ve son zamanlarda çökmeye başladıysa, aradaki değişikliklere bakmak faydalı olacaktır. İlk olarak, sorunun uygulamanın kendisinin yeni bir sürümünden kaynaklanıp kaynaklanmadığını kontrol etmektir. Belki yeni sürümde çökmesine neden olan bir hata var veya belki de uygulamayı kullanma şeklimiz artık desteklenmiyor. Ancak çökmelere neden olabilecek tek değişiklik bu değil. Uygulamamızın kullandığı bir kütüphane veya servis değişmiş olabilir ve artık iyi çalışmıyor olabilir veya genel ortamda bir yapılandırma değişikliği olabilir. Kullanıcı artık belirli bir grupta değilse veya uygulamanın kullandığı dosyalar farklı bir konumda ise gibi. Değişiklikleri anlamaya çalışırken loglar da bilgi kaynağı olabilir. Sistem logunda hangi programların ve kütüphanelerin son zamanlarda güncellendiğini kontrol edebiliriz. Konfigürasyon değişikliklerini kontrol etmek, o yapılandırmayı nasıl yönettiğinize bağlı olarak daha zor olabilir. Ayarlar bir yapılandırma yönetim sistemi aracılığıyla yönetiliyorsa ve değerler bir Sürüm Kontrol Sistemi'nde saklanıyorsa, değişikliklerin tarihine bakabilir ve hangisinin hatayı tetiklediğini anlayabilirsiniz. Bir sorunu çözmeye çalıştığımızda problemin çözümü için üreme durumuna sahip olmanın ne kadar önemli olduğunu birkaç kez söyledik. Bir uygulamayı hata ayıklamaya çalışırken bir üreme durumu bulmak, çökmenin neyin neden olduğunu anlamamıza ve sorunu nasıl düzeltebileceğimizi bulmamıza yardımcı olabilir. Bu nedenle, çökmenin tetikleyen durumu anlamak için biraz zaman harcamak değerlidir. Bu, genel sistem ortamını, özel uygulama yapılandırmasını, uygulama girişlerini, uygulama tarafından üretilen çıkışları, kullandığı kaynakları ve iletişim kurduğu servisleri içerir. Üreme durumu oluştururken, temiz bir sayfa başlamak ve çökmenin tetiklenmesine kadar parçaları yavaşça yerine koymak faydalı olabilir. Bu, uygulamayı yerel olan yerine varsayılan yapılandırma ile veya çökme yapan bilgisayar yerine yeni bir bilgisayar üzerinde denemek gibi şeyleri içerebilir. Ve unutmayın, üreme durumunu mümkün olduğunca küçük yapmak istiyoruz. Bu, sorunu daha iyi anlamamıza ve düzeltmeye çalıştığımızda var olup olmadığını hızlı bir şekilde kontrol etmemize olanak tanır. Ve eğer sorunu düzeltemezsek bile, küçük ve basit bir üreme durumu, hatayı program geliştiricilerine bildirirken son derece yardımcı olur. Bu konuyu özetlemek gerekirse, bir uygulamanın çökmesinin kök nedenini bulmak için tüm mevcut loglara bakmalı, neyin değiştiğini anlamalı, programın yaptığı sistem veya kütüphane çağrılarını izlemeli ve mümkünse en küçük üreme durumunu oluşturmalıyız. Tüm bunları yaptıktan sonra, sorunun kök nedeni hakkında bir fikrimiz olmalı ve belki de nasıl düzeltebileceğimizi bileceğiz. Sorunları düzeltme stratejisi, kodu düzelteyip düzeltemeyeğimize bağlı olarak değişecektir. Bir sonraki videomuzda, programı düzeltemediğinizde ve sorunu atlatmanız gerektiğinde ne yapabileceğinizi göreceğiz. Ve daha sonraki videolarda, hatalı kodları düzeltme stratejilerine derinlemesine bir bakış yapacağız.

When an application crashes and we don't know why we'll want to look for logs that might relate to the failure. To look at logs on Linux will open the system log files and VAR log or the user log files and dot accession errors file. On Mac OS we generally use the console app to look at logs and the event Viewer on Windows. So what kind of data should you look for in these logs most logs have a date and time for each line locked knowing when the application crashed you can look for a log line around that time. And try to find an error message related to the application that crashed. Sometimes the errors will be self-explanatory like permission denied no such file or directory connection refused. Sometimes it will be a cryptic message and you have no idea what it means. Ever we have an error message no matter how weird it seems we can search for it online to try to figure out its meaning. If we're lucky, we might find the official documentation of what that error means and what we can do about it. But even if that's not available, will usually come across posts by others who have tackled a similar error and this additional information can help us understand what's going on. If there are no errors or the errors aren't useful we can try to find out more info by enabling sling debug logging. Many applications generate a lot more output when debugging logging is enabled. We might need to enable it from a setting in the applications configuration file or a command line parameter to pass when running the application manually. By enabling this extra logging information, we can get a better idea of what's actually causing the problem. And what do we need to do if there are no logs or error messages at all. In that case we need to use tools that let us see what going on inside the program. We call that a few are ready. On Linux we use S Trace to see what system calls a programs doing. The equivalent tool is called de trois on Mac OS process monitor is a Windows tool that can also take a peek inside what's going on inside a process on Windows? By tracing which system calls a program is doing we can see what files and directories it's trying open what network connections it's trying to make and what information it's trying to read or write. This can give us a better idea of what caused the actual problem. We could find that the problem is caused by a resource not being present that the program expects to be present. Like we saw with the missing directory example in the earlier module or we could find that the program tries to interact with the graphics interface and there isn't any because it's a service running on a server. Or the program tries to open a file but the user running the software doesn't have the necessary permissions. If the application used to work fine and recently started crashing. It's useful to look into what changed in between. The first thing is to check if the issue is caused by a new version of the application itself. Maybe there's a bug in the new version that causes the crash or maybe the way that we're using the application is no longer supported. But that's not the only possible change that could trigger crashes. It could also be that a library or service used by our application changed and they no longer work well together or it could be that there was a configuration change in the overall environment. Like if the user isn't in a specific group anymore or if the files that the application used are in a different location. When trying to figure out what changed logs can also be a useful source of information. In the system log we can check which programs and libraries were recently updated checking for configuration changes might be harder depending on how you manage that configuration. If the settings are managed through a configuration management system and the values are stored in a Version Control System. Then you might be able to look at the history of changes and figure out which one triggered the failure. We call that a few times already how important it is to have a reproduction case for a problem that we're trying to solve. When we're trying to debug an application that crashes finding a reproduction case can help us both understand what's causing the crash and figure out what we can do to fix it. So it's valuable to spend some time figuring out the state that triggers the crash. This includes the overall system environment the specific application configuration the inputs to the application the outputs generated by the application the resources that uses and the services it communicates with. When trying create the reproduction case it might be useful to start from a clean slate and slowly put the pieces in place until the crash triggers. This might include trying out the application with the default configuration instead of the local one or on a freshly installed computer instead of the computer where it's crashing. And remember we want to make the reproduction case as small as possible this lets us better understand the problem and also quickly check if its present or not when we attempt to fix it. And even if we end up unable to fix the issue having a small and simple reproduction case is extremely helpful in reporting a bug to the program's developers. So to sum this up to find the root cause of a crashing application will want to look at all available logs figure out what changed trace the system or library calls the program makes and create the smallest possible reproduction case. After doing all of this, we should have some idea of what the root cause of the issue is and maybe even how to fix it. The strategy for fixing problems will depend on whether we can fix the code or not. In our next video, we'll check out what you can do when you can't fix the program and need to work around the issue. And in later videos, we'll deep dive into strategies for fixing faulty code.