# Internal Server Error

Bir meslektaşımız, web sunucumuzdaki bir web sayfasının çalışmadığını bildirdi. Daha önce yaptığımız gibi, bunun tam olarak ne anlama geldiğini bulmamız gerekiyor. Meslektaşımızdan daha fazla ayrıntı istedik ve bize başarısız olan web sayfasının **site.example.com/blogs** olduğunu söyledi. Hadi kontrol edelim, bu bizim için de başarısız oluyor mu? İşte, sunucu 500 hatası ile yanıt verdi. Bu hata genellikle uygulamanın sunucu tarafında bir şeyin çöktüğü anlamına gelir, ancak tam olarak ne olduğunu bilmiyoruz. Daha fazla bilgi edinmek için araştırma yapmamız gerekecek. Web sunucusuna bağlanalım ve neyin olduğunu anlamaya çalışalım. İlk adım olarak, Linux sistemlerinde loglara bakmak, logların Bar log konumunda bulunduğunu belirttik. Bunun için, mevcut tarihi kontrol etmek için date komutunu kullanacağız. Bu dizine geçelim ve hatamızla ilgili herhangi bir güncel log olup olmadığını kontrol edelim. Ardından, dosyaları son değiştirme tarihine göre sıralayan Ls -Lt komutunu kullanarak başlatalım ve başlığı en üstte tutmak için başına head komutunu ekleyelim. Hata tetikledik, ancak loglarda son zamanlarda herhangi bir şey görünmüyor gibi görünüyor. Her ihtimale karşı, tail kullanarak error.log dosyasının son satırlarına bakalım. Hayır, burada ilginç bir şey yok. Daha fazla bilgi nasıl elde edebileceğimizi bulmamız gerekiyor, ancak bu bilgisayar üzerinde hangi web gezgini yazılımının kullanıldığını bile bilmiyoruz. Ancak web sunucusunun varsayılan web hizmeti portu olan 80 numaralı portta çalıştığını biliyoruz. 80 numaralı portu dinleyen yazılımın hangisi olduğunu nasıl bulabiliriz? **Netstat** komutunu kullanabiliriz, bu komut, geçtiğimiz bayraklara bağlı olarak ağ bağlantıları hakkında bize bir dizi bilgi verebilir. Bu komut, Linux'ta root yönetici kullanıcısı tarafından sınırlanmış olan bir dizi sokete erişir, bu nedenle sudo ile çağırmamız gerekecek, bu da bize root olarak komutları çalıştırma izni verir, ve ardından bir dizi bayrak geçireceğiz. Netstat. **-n** ile sayısal adresleri çözümlenmiş ana bilgisayar adları yerine yazdırmak için, **-l** ile bağlantıları dinleyen soketleri kontrol etmek için ve **-P** ile her soketin hangi işlem kimliği ve adına ait olduğunu yazdırmak için. Sadece 80 numaralı portu ilgilendiğimizden, çıktıyı bir grep komutuna bağlayarak: 80'ı kontrol edelim. Harika, yeni bilgiler edindik. 80 numaralı portu dinleyen işlemin adının **"nginx"** olduğunu görüyoruz. Popüler web hizmeti uygulamalarından biri. Şimdi sitemizin yapılandırmasını kontrol etmek istiyoruz. Linux'taki yapılandırma dosyaları genellikle etc dizininde saklanır. Bu nedenle **etc/nginx**'ye bakalım. Burada bir sürü dosya var. Web sunucusunda ayarlayabileceğiniz birçok farklı yapılandırma seçeneği. Belirli bir siteyle ilgili yapılandırmayı arıyoruz, bu nedenle **etc/nginx/sites-enabled**'e bakalım. Burada iki dosya var, biri varsayılan site için, diğeri de site.example.com sitesi için, işte bu dosyayı istiyoruz. VI düzenleyici ile açalım. Burada pek fazla bir şey yok, ancak en altta **uwsgi_pass** ve ardından localhost adresi ile farklı bir port numarası yazdığını görüyoruz. Bu web sitesi, doğrudan nginx'den hizmet almak yerine, yazılım bağlantı kontrolünü uWSGI'ye devrediyor gibi görünüyor, bu da dinamik sayfalar oluşturan programlarla bir Web sunucusunu bağlamak için yaygın olarak kullanılan bir çözümdür. Şimdi bunun yapılandırmasını bulabilir miyiz? VI'den çıkarak iki nokta q yazalım ve sonra etc/uwsgi'ye bakalım, burada sadece iki dizin görüyoruz, apps-available ve apps-enabled. Öyleyse apps-enabled'ı kontrol edelim. Harika, sitemizin uWSGI yapılandırmasını bulduk. Şimdi kontrol edelim. Güzel. Bu dosyada daha fazla bilgi var. Ana uygulama dizininin **srv/site.example.com** olduğunu, uygulamaların dub-dub-dub Veri Kullanıcısı ve Grubu olarak çalıştığını, **prod.py** adlı bir Python üç betiğini çalıştırdığını, logunun **var/log/site.log**'da saklandığını ve bir dizi diğer bilgiyi görebiliyoruz. Peki, bu ek bilgileri kullanalım ve neyin yanlış olduğunu bulalım. Bir kez daha iki nokta q ile çıkış yapalım ve ardından o günlüğü kontrol edelim. Garip, günlük dosyasının boyutu sıfır, bu doğru görünmüyor. Başka bir şey bulabilir miyiz bakalım. Python betiğine bakarak başarı elde edemezsek, bir sorun olduğunu düşündüğümüz **log rotate** yapılandırmasıyla ilgili bir şeylerin yanlış olabileceğini şüpheleniyoruz, ancak bununla ilgili daha fazla bilgi bulmak için araştırmaya devam etmemiz gerekecek. Bu video'da başarısız olan bir uygulamanın neyin olduğunu nasıl anlayabileceğimizi inceledik. Neyin olduğunu anlamamıza ve kök nedeni bulana kadar daha fazla bilgi edinmemize yardımcı olabilecek çeşitli araçlar ve fikirler kontrol ettik. Umarım bu derslerin, işinizde kesinlikle karşılaşacak olduğunuz sorunları teşhis etme ve çözme konusunda değerli araçlar sağladığını görmeye başlıyoruz. Şimdi, bilgisayarınızın çökmesine neden olabilecek farklı şeyler hakkında daha fazla bilgi edinmek için bazı bağlantılar içeren bir okuma ve ardından kısa bir pratiğimiz var.

A colleague has alerted us that a webpage on our Web server isn't working. As we've done before, we need to figure out what this means exactly. We asked our colleague for more details and they told us that the failing webpage is at site.example.com/blogs. Let's check out if this is failing for us as well. There it is, the server responded with a 500 error. This error usually means that something on the server side of the application crashed, but we have no idea what. We'll need to investigate to find out more information. Let's connect to the Web server and try to figure out what's up. The first step is looking at logs, as we called out on Linux systems, logs are located in Bar log. To do that, we'll use the date command to check the current date. Let's change into that directory and check out if there are any recent logs about our error and then the Ls -Lt command which sorts the files by the last modified date connecting it to the head command to keep the top 10 lines. We just triggered the error but there doesn't seem to be anything recent in the logs. Just in case, let's check out the last lines insists log using tail. Nope. Nothing interesting here. We need to figure out how we can get more information, but we don't even know which web surfing software is being used on this computer. But we do know that the Web server is running on port 80, the default web serving port. How can we find which software is listening on port 80? We can use the netstat command which can give us a bunch of information about our network connections depending on the flags we pass. This command accesses a bunch of sockets that are restricted to route the administrator user on Linux. So we'll need to call it with sudo which lets us run commands as root, and then we'll pass a bunch of flags netstat. We'll use -n to print numerical addresses instead of resolving host names. L to only check out the sockets that are listening for connection, and P to print the process ID and name to which each socket belongs. Since we only care about port 80, we'll connect the output to a grep command checking for colon 80. Great, we got new information. We see that the process listening in port 80 is called "nginx." One of the popular web serving applications out there. We now want to check out the configuration for our site. Configuration files on Linux are stored in the etc directory. So let's look at etc/nginx. There's a bunch of files here. Lots of different configuration options that you can set in the Web server. We're looking for the configuration related to a specific site. So let's look at etc/nginx sites-enabled. There are two files here one for the default site and one for the site.example.com site that's the one we want. Let's open it with the VI editor. There's not a lot here, but at the bottom we see that it says uwsgi_pass, and then the local host address followed by a different port number. It seems that this website isn't being served directly from nginx, instead, the software is passing the control of the connections to uWSGI which is a common solution used to connect a Web server to programs that generate dynamic pages. So let's see if we can find the configuration for that one. We'll exit VI with a colon q and then see if there's anything interesting in etc/uwsgi. Here we only see two directories, apps-available and apps-enabled. Let's say it's an apps-enabled. Cool. We found the uWSGI configuration for our site. Let's check it out. Nice. This file has a lot more information. We see that the main directory for the application is srv/site.example.com that the applications run as the dub-dub-dub Data User and Group, that it's running a Python three script called prod.py that the log is stored in var/log/site.log and a bunch of other things. All right. Let's use this extra information and see if we can find out what's that. Let's exit with colon q once more and then check out that log file. Weird, the log file has a size of zero, that doesn't seem right. Let's see if we can find out anything else by looking at the Python script that's executed by uwsgi srv/site.example.com prod.py. There's a few different webpages configured in this file. It uses bottle which is a Python module to generate dynamic web pages. At the bottom, we see the configuration for the logs page that's currently failing. Hopefully, a colleague left a comment saying that we can get debugging information by uncommenting the line that calls bottle.debug. That's exactly what we need. To uncomment this line, we need to have write access to the file though, and VI is open in read only mode currently. Let's exit an open again with sudo to be able to modify it. Okay. We've made the change, let's save it and reload uwsgi as the instructions say. We'll do this by running sudo service uwsgi reload. We've added debugging information. Hopefully, that will tell us why the pages failing. Let's reload the website and see what happens. Great news, this time we see a trace back of the error and we see that the issue is that the application is getting a permission denied error when trying to open var/log/site.log. Remember that we thought it was weird that the file was empty, it seems that it's somehow broken. Let's look at it again, this time let's check if there are any other files that start with site. So there's a site.log file and a site.log.1 file. That's pretty common when using log rotate to rotate the logs and avoid them getting too big. But there's something else afoot here. See how one file belongs to the root user and the other belongs to the dub-dub-dub data user. If you look at the permissions of the file, you might notice that they are set to allow the owner to write them and the owner and the group to read them, but the rest of the users can't access them. We saw earlier that the application is running with the dub-dub-dub data user. So if site.log belongs to the root user, the application won't be able to either read or write to this log file. Ding-ding-ding seems like we found the root cause of our issue. Let's change the owner of the site.log file to fix the immediate problem. Let's try reloading our page now. Yes, it works. The log is empty now because the application have not been able to write to it. But if we keep reloading, we'll see how it populates with our entries. All right. We've fixed the immediate problem our Web pages working once again, but we still need to take care of the long-term remediation. Why was the ownership of the file wrong? We suspect that there might be something wrong with the log rotate configuration but we'd need to keep looking to find out what's up with that. In this video, we looked into how we can figure out what's up with an application that's failing. We checked out a bunch of different tools and ideas that can help us understand what's going on and get more information until we can find the root cause. I hope we're starting to see how these lessons provide valuable tools for diagnosing and solving issues that will for sure occur at your job. Up next, we have a reading with some links to learn more about different things that can make your computer crash, then a quick practice quiz.