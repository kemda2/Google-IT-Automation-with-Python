# Unhandled Errors and Exceptions

Son videomuzda, bir programın geçersiz belleğe erişmeye çalıştığında neler olacağı hakkında birçok konuştuk. Belleği doğru bir şekilde işlemek zordur, bu yüzden Python, Java veya Ruby gibi birçok farklı programlama dilinin bunu bizim için yaptığı bir dizi dil vardır. Ancak bu, bu dillerle yazılan programların garip sorunlar oluşturamayacağı anlamına gelmez. Bu dillerde, bir program kodda doğru bir şekilde işlenmeyen beklenmeyen bir durumla karşılaştığında, hatalar veya istisnalar tetiklenir. Örneğin Python'da, bir liste sonundan sonra bir öğeye erişmeye çalışırsak bir indeks hatası alabiliriz. Bir değişkenin düzgün başlatılmamış olması durumunda bir tip hatası veya bir özellik hatası alabiliriz, veya sıfıra bölme hatası alabiliriz eğer sıfıra bölme girişiminde bulunursak. Kod, bu hatalardan birini doğru bir şekilde işleme almadığında, program beklenmedik bir şekilde sona erer. Genel olarak, işlenmemiş hatalar, kodun yanlış varsayımlar yapmasından kaynaklanır. Belki program, mevcut olmayan bir kaynağa erişmeye çalışıyor veya kod, kullanıcının bir değer gireceğini varsayıyor, ancak kullanıcı bunun yerine boş bir dize girdi. Veya belki uygulama, bir değeri başka bir formata dönüştürmeye çalışıyor ve değer ilk beklentilerle eşleşmiyor. Bu tür hatalar meydana geldiğinde, programı yürüten yorumlayıcı, hatanın türünü, hataya neden olan satırı ve izleme bilgisini yazdırır. İzleme bilgisi, sorunun meydana geldiği sırada yürütülen farklı işlevlerin satırlarını gösterir. Birçok durumda, hata mesajı ve izleme bilgisi bize olayın ne olduğunu anlamak için yeterli olabilir ve sorunu çözmeye geçebiliriz. Ancak maalesef her zaman böyle olmaz. Bir kod parçasının bir işlevde çökmesi, hatanın zorunlu olarak o işlevde olması anlamına gelmez. Örneğin, sorunun, daha önce çağrılmış bir işlev tarafından bir değişkenin kötü bir değere ayarlanmasına neden olmuş olabilir. Bu nedenle hata mesajı yeterli olmadığında, kodun nerede yanlış gittiğini bulmak için kodu hata ayıklamamız gerekecek. Bunun için, uygulamanın diline özgü olarak mevcut olan hata ayıklama araçlarını kullanabiliriz. Python programları için **BDB etkileşimli hata ayıklayıcıyı** kullanabiliriz, bu da bize kod satırlarını tek tek yürütme veya değişkenlerin nasıl değer değiştirdiğine bakma gibi tüm tipik hata ayıklama işlemlerini yapma imkanı tanır. Bir işlevin yanlış davranışını anlamaya çalıştığımızda, hata ayıklama araçlarını kullanmanın yanı sıra, kodun yürütülmesi ile ilgili verileri içeren ifadeleri eklemek yaygın bir uygulamadır. Bu tür ifadeler, değişkenlerin içeriğini, işlevlerin geri dönüş değerlerini veya bir listenin uzunluğu gibi metadata gibi kodun yürütülmesiyle ilgili verileri gösterebilir. Bu tekniğe "printf hata ayıklama" denir. Adı, C programlama dilinde ekrana mesaj yazdırmak için kullanılan printf işlevinden gelir. Ancak bu tekniği tüm dillerde kullanabiliriz, ekrana metni göstermek için print, puts veya echo kullansak da. Bir adım daha ileri gidelim. Kodu ekrana mesaj yazacak şekilde değiştirirken, en iyi yaklaşım, hata ayıklama bilgisini istediğimizde kolayca etkinleştirilebilecek veya devre dışı bırakabilecek bir şekilde eklemektir. Python'da bunu **logging modülünü** kullanarak yapabiliriz. Bu modül, kodumuzun ne kadar kapsamlı olmasını istediğimizi belirlememize olanak tanır. Tüm hata ayıklama mesajlarını içerip içermediğimizi veya yalnızca bilgi, uyarı veya hata mesajlarını içerip içermediğimizi belirtebiliriz. Ardından mesajı yazarken, ne tür bir mesaj yazdığımızı belirtiriz. Bu şekilde hata ayıklama düzeyini bir bayrak veya yapılandırma ayarı ile değiştirebiliriz. Peki, beklenmedik bir istisna nedeniyle oluşan sorunu çözdüğünüzde ne yaparsınız? Çözüm, programlama hatasını düzeltmek olabilir, yani değişkenlerin kullanılmadan önce başlatıldığından veya kodun bir listenin sonundan sonra öğelere erişmeye çalışmadığından emin olmak olabilir. Veya kodun düşünülmemiş belirli kullanım durumlarına uygun hale getirilmesi gerekebilir. Genel olarak, programı başarısızlıklara karşı daha dirençli hale getirmek istersiniz. Beklenmeyen bir şekilde çökmesi yerine, programın kullanıcıya sorunu bildirmesini ve ne yapmaları gerektiğini söylemesini istersiniz. Örneğin, bir uygulamanızın bir izin reddi hatası ile çöktüğünü varsayalım. Beklenmedik bir şekilde programın bitmesi yerine, kodu bu hatayı yakalamak ve kullanıcıya izin sorununun ne olduğunu bildirmek, böylece bunu düzeltebilmelerini sağlamak istersiniz. Örneğin, yeni dosyalar yazamıyor, lütfen kullanıcınızın temp dizininde yazma izinlerine sahip olduğundan emin olun. Bazı durumlarda, programımızın belirli koşullar karşılanmadan çalışması anlamsız olabilir. Bu durumda, hata tetiklendiğinde programın bitmesi normaldir. Ancak yine de, kullanıcıya sorunu nasıl düzelteceklerini söyleyen bir şekilde yapmalıdır. Örneğin, bir uygulamanın bir veritabanına bağlanması kritikse ve veritabanı sunucusu yanıt vermiyorsa, uygulamanın veritabanı sunucusuna bağlanamıyor hatası ile sona ermesi mantıklıdır. Ayrıca, bağlantı girişiminin ayrıntılarını içermek de mantıklıdır, bu da kullanılan ana bilgisayar adı, bağlantı için kullanılan port veya kullanıcı adı gibi şeyleri içerebilir. Bu nedenle özetle, eğer programınız işlenmemiş bir hata ile çöküyorsa, önce sorunu anlamak için bazı hata ayıklama işlemleri yapmak istersiniz. Bir kere çözdüğünüzde, programlama hatalarını düzelttiğinizden ve bir hatayı tetikleyebilecek koşulları yakaladığınızdan emin olmak istersiniz. Bu şekilde programın çökmesini ve kullanıcılarınızın hayal kırıklığına uğramasını önleyebilirsiniz. Şimdi, başkasının kodunu düzeltmeye çalıştığınızda ne yapabileceğiniz hakkında biraz konuşacağız.

In our last video, we talked a lot about what happens when a program tries to access invalid memory. Correctly handling memory is a hard problem, and that's why there's a bunch of different programming languages like Python, Java, or Ruby that do it for us. But that doesn't mean programs written in these languages can't trigger weird problems. In these languages, when a program comes across an unexpected condition that isn't correctly handled in the code, it will trigger errors or exceptions. In Python, for example, we could get an index error if we tried to access an element after the end of a list. We might get a type error or an attribute error if we try to take an action on a variable that wasn't properly initialized or division by zero error if we tried to well, divide by zero. When the code generates one of these errors without handling it properly, the program will finish unexpectedly. In general, unhandled errors happen because the codes making wrong assumptions maybe the program's trying to access a resource that's not present or the code assumes that the user will enter a value but the user entered and empty string instead. Or maybe the application is trying to convert a value from one format to another and the value doesn't match the initial expectations. When these failures happen, the interpreter that's running the program will print the type of error, the line that caused the failure, and the traceback. The traceback shows the lines of the different functions that were being executed when the problem happened. In lots of cases, the error message and traceback info already gives us enough to understand what's going on, and we can move on to solving the problem. But sadly, that's not always the case. The fact that a piece of code crashes on one function doesn't mean that the error is necessarily in that function. It's possible, for example, that the problem was caused by a function called earlier which set a variable to a bad value. So the function where the code crashes is just accessing that variable. So when the error message isn't enough, we'll need to debug the code to find out where things are going wrong. For that, we can use the debugging tools available for the application's language. For a Python, program we can use the BDB interactive debugger which lets us do all the typical debugging actions like executing lines of code one-by-one or looking at how the variables change values. When we're trying to understand what's up with a misbehaving function on top of using debuggers, it's common practice to add statements that print data related to the codes execution. Statements like these could show the contents of variables, the return values of functions or metadata like the length of a list or size of a file. This technique is called print f debugging. The name comes from the print f function used to print messages to the screen in the C programming language. But we can use this technique in all languages, no matter if we use print, puts, or echo to display the text on the screen. Let's take this one step further. When changing code to print messages to the screen, the best approach is to add the messages in a way that can be easily enabled or disabled depending on whether we want the debug info or not. In Python, we can do this using the logging module. This module, lets us set how comprehensive we want our code to be. We can say whether we want to include all debug messages, or only info warning or error messages. Then when printing the message, we specify what type of message we're printing. That way, we can change the debug level with a flag or configuration setting. So you figured out why the unexpected exception was thrown, what do you do next? The solution might be fixing the programming error like making sure variables are initialized before they're used or that the code doesn't try to access elements after the end of a list. Or it could be that certain use cases that hadn't been considered needs to be added to the code. In general, you'll want to make the program more resilient to failures. Instead of crashing unexpectedly, you want the program to inform the user of the problem and tell them what they need to do. For example, say you have an application that crashes with a permission denied error. Rather than the program finishing unexpectedly, you'll want to modify the code to catch that error and tell the user what the permission problem is so they can fix it. For example, unable to write new files and temp, make sure your user has bright permissions on temp. In some cases, it doesn't make sense for our program to even run if certain conditions aren't met. In that case, it's okay for the program to finish when the error is triggered. But again, it should do so in a way that tells the user what to do to fix the problem. For example, if it's critical for an application to connect to a database but the database server isn't responding, it makes sense for the application to finish with an error saying unable to connect to the database server. It also makes sense to include all details of the attempted connection like the host name, the port, or the username used to connect. So to recap, if your program is crashing with an unhandled error, you want to first do some debugging to figure out what's causing the issue. Once you figured it out, you want to make sure that you fix any programming errors and that you catch any conditions that may trigger an error. This way, you can make sure the program doesn't crash and leave your users frustrated. Up next, we'll talk a bit about what you can do when you're trying to fix someone else's code.