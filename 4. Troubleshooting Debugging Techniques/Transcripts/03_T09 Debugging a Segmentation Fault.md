# Debugging a Segmentation Fault

Geçmiş videolarda birçok farklı çökme türünü tartıştık. Şimdi bir segmentasyon hatasının nasıl göründüğüne bir göz atalım. Bir seg fault ile çöken basit bir örnek programımız var. Bir uygulama bu şekilde çöktüğünde, çökme anına ilişkin tüm bilgileri içeren bir çekirdek dosyasına sahip olmak yararlıdır, böylece biz veya başka biri neyin olduğunu hata ayıklamak için kullanabilir. Bu, çökme anında bir görüntü çekmek ve daha sonra analiz etmek gibidir. Bu çekirdek dosyalarını oluşturmak istediğimizi işletim sistemine belirtmemiz gerekiyor. Bunun için **ulimit** komutunu çalıştırarak **-c** bayrağını çekirdek dosyaları için ve ardından **unlimited** diyerek herhangi bir boyutta çekirdek dosyaları istediğimizi belirtiyoruz. Bu işlemi yaptıktan sonra örnek programımızı tekrar çalıştırmayı deneyebiliriz. Peki, çöken programımız bir çekirdek dosyası oluşturdu. Şimdi bunu **LS-L** kullanarak kontrol edelim. Bu dosya, program çöktüğünde ne olduğuna dair tüm bilgileri içerir. Programın neden çöktüğünü anlamak için bu dosyayı GDB hata ayıklayıcıya ileterek kullanabiliriz. Ona bir çekirdek dosyası vermek ve ardından çöken yürütülebilirin nerede bulunduğunu belirtmek için **gdb-c core** ve ardından **example** diyoruz. Başladığında, GDB bir dizi mesaj gösterir, bunlar arasında sürümü, lisansı ve yardım almanın yolları bulunur. Ardından, programın bir segmentasyon hatası ile bittiğini belirtir. Çökmenin sistem kütüphanelerinin bir parçası olan bir dosyada **strlen** fonksiyonu içinde gerçekleştiğini gösterir. Burada gördüğümüz no such file or directory hatası, o sistem kütüphanesinin hata ayıklama sembollerine sahip olmadığımız anlamına gelir, ancak bu sorun değil. strlen fonksiyonuna doğru çalışmasına güveniyoruz. Kodumuz hatalı. Şimdi çökmenin tam geri izlemesine **backtrace** komutunu kullanarak bakalım. Listede ilk öğe, çökmenin meydana geldiği fonksiyondur. İkinci öğe, fonksiyonu çağıran fonksiyondur ve böyle devam eder. Bu durumda, başarısız olan strlen fonksiyonunun, kodumuzdaki **copy parameters** fonksiyonu tarafından çağrıldığını ve bu fonksiyonun da **main** fonksiyonu tarafından çağrıldığını görüyoruz. Geri izlemedeki çağrılan fonksiyona gitmek ve çökme nedeniyle hata alan copy parameters'ın satırını kontrol etmek için **up** komutunu kullanabiliriz. Hatalı satırın strlen fonksiyonunu çağıran satır olduğunu görüyoruz, ancak neden başarısız olduğu net değil. Başarısız olan kodun bağlamını daha fazla bilgi almak için etraftaki satırları gösteren **list** komutunu çağırabiliriz. Burada bir C kodu parçası görüyoruz. Eğer bu, C koduna ilk kez bakıyorsanız, biraz karışık görünebilir. Bu normaldir. Python ile bazı benzerlikler var, ancak biraz farklı olan bazı şeyler de var. Hatalı satırın, 10. satır, bir for döngüsü içinde olduğunu görüyoruz. For döngüsünün kullanıldığı değişken i olarak adlandırılan bir değişkeni var. İşte çökmeyi oluşturan an, 10. satırdaki bu değişkeni kullanmaktadır. İşte print komutunu kullanarak i'nin değerini kontrol etmek. GDB, sonuçları yazdırmak için her birine ayrı bir tanımlayıcı vermek için dolar işareti ve ardından bir sayı kullanır. Bu durumda, sonuç bir'dir. Başka bir deyişle, çökme meydana geldiğinde i'nin değeri bir idi. Bu değişken, bir diziyi erişmek için kullanılıyorsa **argv** adlı bir diziye, o zaman argv 0'ın içeriğini ve ardından argv 1'in içeriğini yazdıralım. 0x ile başlayan o tuhaf sayılar nedir? Bunlar onaltılık sayılardır ve bellekteki bazı verilerin depolandığı adresleri göstermek için kullanılır. Burada GDB, bize argv dizisinin ilk elemanının ./example dizesine işaret eden bir işaretçi olduğunu söylüyor. İkinci elemanın, sıfır olarak da bilinen bir boş işaretçiye işaret ettiğini söylüyor. Sıfır asla geçerli bir işaretçi değildir. Genellikle C'deki veri yapılarının sonunu belirtir. Yani kodumuz diziye ikinci elemanı erişmeye çalışıyor, ancak dizi sadece bir geçerli elemana sahip. Başka bir deyişle, for döngüsü bir fazla iterasyon yapıyor. Bu, bir fazla bir hata olarak bilinir ve oldukça yaygın bir hatadır. Bu durumda, düzeltme gerçekten basittir. İterasyonun bir eleman önce durması için eşit olmayan bir işareti sıkı işaretleme işaretine değiştirmemiz gerekiyor. Bu videoda, bir segmentasyon hatası ile çöken C uygulamalarını hata ayıklamanın nasıl olduğuna bir bakış attık. Bir sonraki videoda, bir istisna ile çöken Python uygulamalarını nasıl hata ayıklayabileceğimizi tartışacağız.

Over the past videos, we've discussed a bunch of different types of crashes. Let's now check out what a segmentation fault looks like in action. We have a simple example program that crashes with a seg fault. When an application crashes like this, it's useful to have a core file of the crash. Core files store all the information related to the crash so that we or someone else can debug what's going on. It's like taking a snapshot of the crash when it happens to analyze it later. We need to tell the OS that we want to generate those core files. We do that by running the ulimit command, then using the -c flat for core files, and then saying unlimited to state that we want core files of any size. Once we've done that, we can try executing our example again. All right, our crashing program has generated a core file. Let's check it out using LS-L. This file contains all the information of what was going on with the program when it crashed. We can use it to understand why the program crashed by passing it to the GDB debugger. We'll call it gdb-c core to give it a core file and then example to tell it where the executable that crashed is located. When it starts, GDB shows a bunch of messages including its version, license, and how to get help. It then tells us that the program finished with a segmentation fault. It shows that the crash happened inside the strlen function in a file that's part of the system libraries. The no such file or directory error that we're seeing here means that we don't have the debugging symbols for that system library, but that's okay. We trust the strlen function to work correctly. It's our code that's buggy. Let's look at the full backtrace of the crash by using the backtrace command. The first element in the list is the function where the crash occurred. The second element is the function that called the function and so on. In this case, we see that the strlen function that failed was called by the copy parameters function in our code which was called by the main function. We can use the up command to move to the calling function in the backtrace and check out the line and copy parameters that caused the crash. We see that the faulty line is calling the strlen function, but it's not clear why that would fail. We can get more contexts for the code that failed by calling the list command that shows the lines around the current one. Here, we see a chunk of C code. If this is the first time you look at C code, it might seem a bit confusing. That's okay. There are some similarities with Python, but also, some things that are pretty different. We see that the faulty line, line 10, is in the body of a for loop. The variable that the for loop uses to iterate is called i. Let's check out the value of i using the print command. GDB uses the dollar sign followed by a number to give separate identifiers to each result it prints. In this case, the result is one. In other words, when the crash happened, I had the value of one. Since this variable is being used to access an array called argv, let's print the contents of the first element argv 0, and then the second element argv 1. What are those weird numbers starting with 0x? Those are hexadecimal numbers, and they are used to show addresses in memory where some data is stored. Here, GDB is telling us that the first element in the argv array is a pointer pointing to the./example string. The second element is a pointer to zero also known as a null pointer. Zero is never a valid pointer. It usually signals the end of data structures in C. So our code is trying to access the second element in the array, but the array only has one valid element. In other words, the for loop is doing one iteration to many. This is known as an off-by-one error, and it's a super common error. In this case, the fix is really simple. We need to change the less than or equal sign to be a strictly less than sign so that the iteration stops one element before. In this video, we've got a sneak peek at what it's like debugging C applications that crashed with a segmentation fault. Up next, we'll talk about how we can debug Python applications that crash with an exception.