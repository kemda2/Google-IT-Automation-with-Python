# Debugging a Python Crash

Son videomuzda, bir uygulamanın bir segmentasyon hatası ile çöktüğünü inceledik. Bu tür sorunlar, genellikle C veya C++ gibi dillerde yazılmış uygulamalarla uğraşırken karşılaşılan yaygın sorunlardır. Öte yandan, Python gibi diller kullanırken genellikle beklenmeyen istisnalarla uğraşmamız gerekebilir ve bu durum programımızın çökmesine neden olabilir. Bir örnek inceleyelim. Şirketimizin veritabanındaki bazı ürünlerin açıklamalarını güncelleyen bir betiğimiz var. Bu, bir CSV dosyasını parametre olarak alır ve ürün kodu ve açıklama kullanılarak içe aktarılacak verileri içerir. Betiğimiz basitçe bir dosyayı okur ve ardından veritabanını günceller. Genellikle çoğu zaman sorunsuz çalışır. Ancak, yeni açıklamalar içeren dosya belirli bir kullanıcı tarafından oluşturulduğunda, program bir istisna ile başarısız olur. Kullanıcı, bize bir hata içeren bir dosya gönderdi, böylece neyin yanlış gittiğini anlamaya çalışabiliriz. İlk olarak, dosyanın içeriğine bakalım. Tamam, bu yeterince zararsız görünüyor. Şimdi, programı çalıştırmayı deneyelim. Program bir istisna ile başarısız oldu. Bu hatayı daha iyi anlamak için bu izlemeye bir göz atalım. En altta, istisnanın adını görüyoruz. Bu durumda, Key Error ve bu durumda hata yapan anahtarın adı olan product code. Bundan üstte, iki satırı işlev başına olmak üzere bir işlev çağrısı listesi görüyoruz. İlk satır, işlevi içeren Python dosyasını, satır numarasını ve işlevin adını belirtir. İkinci satır, o satırın içeriğini gösterir. Bu bilgi, önceki videomuzda gördüğümüz geri izleme ile benzerdir. Ancak, işlevlerin sırası tersine çevrilmiştir. En alttaki işlev, istisna meydana geldiği yerdir. Üzerinde, update data'nın main tarafından çağrıldığını ve bunun üstünde main'in modül düzeyindeki satır tarafından çağrıldığını görüyoruz. Peki burada ne oluyor? update data işlevi, bir değişken olan row'daki ürün kodu alanlarına erişmeye çalışıyor. Ancak bir nedenle bu, bir Key Error ile başarısız oluyor. Genellikle, istisna iletileri ve istisnanın meydana geldiği satırı bilmek, genellikle neyin yanlış gittiğini anlamak için yeterlidir. Ancak bu gibi durumlarda, bu yeterli değildir. Şimdi bir Python hata ayıklayıcısını kullanmayı deneme zamanı. Aygıt hata ayıklayıcıyı çalıştırarak başlayacağız ve ardından çalıştırmak istediğimiz komut dosyasını ve komut dosyasının ihtiyaç duyduğu herhangi bir parametreyi ileteceğiz. Bizim durumumuzda **pdb3 update products.py new products.csv**'yi çağıracağız. Hata ayıklayıcıyı başlattığımızda, betiğimizin ilk satırında konumlandırılır ve ne yapmasını istediğimizi söylememizi bekler. Her bir komut dosyasındaki talimatları birer birer next komutunu kullanarak çalıştırabilirdik. Ancak burada çok şey oluyor. Bu yüzden çökene kadar veya bitene kadar yürütmeye devam etmesini söyleyebiliriz. Şimdi bunu yapalım. Program aynı şekilde başarısız oldu, daha önce gördüğümüz gibi. Ancak şimdi hata nedeni hakkında daha iyi bir fikir edinmek için hata ayıklayıcıyı kullanabiliriz. row'un içeriğini yazdıralım. Bu gerçekten tuhaf. product code'dan önce görünen bu karakterler nedir? Bu karakter dizisinin sıralamasını çevrimiçi olarak araştırırsak, bunların Little-endian ve Big-endian kullanılarak depolanan bir dosyayı birbirinden ayırmak için UTF-16'da kullanılan Byte Order Mark veya BOM'u temsil ettiğini buluruz. Dosyamız UTF-8'de olduğu için BOM'a ihtiyaç duymaz. Ancak bazı programlar hala ekler ve bu betiğimizi rahatsız ediyor. Peki ne yapabiliriz? Neyse ki, başkaları zaten aynı sorunla karşılaştı ve bir çözüm buldu. open işleminin encoding parametresi olarak ayarlayabileceğimiz UTF-8-sig adlı özel bir değer vardır. Bu kodlama parametresini ayarlamak, Python'un dosyalar onu içerdiğinde BOM'u ortadan kaldırmasını ve içermediklerinde olduğu gibi davranmasını sağlar. Şimdi betiğimizin kodunu bu varsayılan yerine kullanacak şekilde değiştirelim. Dosyayı açtığı yer olan encoding parametresini arayacağız, ardından değer olarak UTF-8-sig'i ekleyeceğiz. Tamam, değişikliği yaptık. Şimdi çalışacak mı? Bir kontrol edelim. Evet, sorunu çözdük. Betiğimiz artık BOM içeren ve içermeyen dosyalarla çalışabilir. Son iki videoda GDB ve PDB'yi kısaca inceledik. Hata ayıklayıcılarla yapabileceğimiz birçok işlemin yüzeyini henüz yeni çizdik. Daha gelişmiş hata ayıklayıcı özellikleri de bulunmaktadır. Örneğin, belirli bir kod satırının yürütüldüğü yere kadar kodu çalıştırma veya bir değişken veya ifade değiştiğinde kadar kodu çalıştırma gibi. Ayrıca, kodu adım adım inceleyebilir ve bir sorun meydana geldiğinde kontrol edebiliriz. Ancak burada bu ileri tekniklere girmeyeceğiz. Ancak, her zamanki gibi, daha fazla bilgi öğrenmek istiyorsanız bununla ilgili sonraki okumalara ek bilgiler ekleyeceğiz. Bundan sonra, tüm bunların anlamını kontrol etmek için başka bir uygulama sınavı var.

In our last video, we looked into an application that was crashing with a segmentation fault. That kind of problem is common when dealing with applications written in languages like C or C++. On the flip side, when using languages like Python, we usually need to deal with unexpected exceptions making our program crash. Let's look at one example of that. We have a script that updates the descriptions of some products in our company's database. It's a pretty simple script that takes a CSV file as a parameter, which includes the data that needs to be imported using the product code and description. Our script simply reads through a file and then updates the database. Most of the time it works just fine. But when the file with the new descriptions is generated by one specific user, the program fails with an exception. The user has sent us a file that's failing so that we can try to figure out what's going on. Let's first check out the contents of the file. Okay, this seems harmless enough. Let's try executing the program. The program failed with an exception. Let's have a look at this trace back to understand it a bit better. At the bottom, we see the name of the exception. In this case, Key Error and the message in this case, product code, which is the name of the key that's failing. Above that, we see a list of function calls with two lines per function. The first line tells us the Python file that contains the function, the line number, and the name of the function. The second line shows us the contents of that line. This information is similar to the back-trace that we saw in our last video. But the order of the functions is reversed. The function at the bottom, update data, is the one where the exception occurred. Above it, we see that update data was called by main, and on top of that we see that main was called by the line at the module level. So what's going on here? The update data function is trying to access the product code fields in a variable named row. But for some reason this is failing with a Key Error. Frequently, knowing the exception message and the line where the exception happened, is already enough to understand what's going on. But in some cases like this one, that's not enough. It's time to try our hand at using a Python debugger. We'll start the debugger by running pdb3 and then passing the script that we want to run and any parameters that our script needs. In our case, we'll call pdb3 update products.py new products.csv. When we start the debugger it gets positioned at the first line of our script and waits for us to tell it what to do. We could run each of the instructions in the file one by one using the next command. But there's a lot going on here. So we need to go through a lot of lines until we reach the failure. Alternatively, we can tell the debugger to continue the execution until it either finishes or crashes. Let's do that now. So the program failed in the same way we'd seen before. But now we can use the debugger to get a better idea of why we're getting this pesky key error. Let's print the contents of row. That's really weird. What are those characters appearing before product code? If we search online for the sequence of characters, will find that they represent the Byte Order Mark or BOM which is used in UTF-16 to tell the difference between a file stored using Little-endian and Big-endian. Our file is in UTF-8 so it doesn't need the BOM. But some programs still include it and this is tripping up our script. So what can we do? Fortunately, others have already faced the same issue and figured out a solution. There is a special value called UTF-8-sig that we can set as the encoding parameter of the open function. Setting this encoding means that Python will get rid of the BOM when files include it and behave as usual when they don't. Let's change the code of our script to use that encoding instead of the default. We'll look for the place where it's opening the file, then add the encoding parameter with UTF-8-sig as the value. All right. We've made the change. Will they work now? Let's check it out. Yeah. We've fixed the problem. Our script can now work with users generating files with and without the Byte Order Mark. In the last two videos, we looked briefly at GDB and PDB. We've barely discussed the surface of the many operations that we can do with debuggers. There are ton more advanced debugging features. Like setting breakpoints the letter code run until certain line of code is executed or watch points that letter code run until a variable or expression changes. We can also step through the code instruction by instruction to check when a problem happens and much more. We won't look into any of these advanced techniques here. But as usual, we'll put more information about this in the next reading in case you want to learn more. After that, there's another practice quiz to check out to make sure all of this has made sense.