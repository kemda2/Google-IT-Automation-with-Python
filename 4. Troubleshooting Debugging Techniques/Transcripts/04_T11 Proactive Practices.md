# Proactive Practices

IT uzmanları ve böcek ilaçlayıcılarının ortak noktası, hata ayıklama ile uğraşmaktır. İyi bir kodlama şakasını gerçekten çok seviyorum. Her neyse, devam edelim, bu yazılımımızdaki hatalar olabilir veya başkalarının yazılımındaki hatalar olabilir. Ancak programlarımızda birçok farklı hataya neden olan birçok hata ile karşılaşacağız. Hayatımızı kolaylaştırmak için benimseyebileceğimiz bir dizi strateji var; sorunlar kullanıcılarımızı etkilemeden önce sorunları yakalamak veya daha iyi bilgiye sahip olarak sorun gidermeyi basitleştirmek. Bunlardan birkaçına burada ve orada değindik, ancak şimdi derinlemesine inme zamanı geldi. Bir kesinti olduğunda hızla düzeltme yapmak zorunda kalmamak için, değişiklikleri önceden test etmemize izin veren bir altyapıya sahip olmak gerçekten yardımcı olur, böylece şeylerin kullanıcılara ulaşmadan önce beklediğimiz gibi çalıştığını kontrol edebiliriz. Eğer kodu biz yazıyorsak, bir şey yapabileceğimiz şey, kodumuzun iyi bir birim testleri ve entegrasyon testleri olduğundan emin olmaktır. Testlerimiz kodun iyi bir kapsamına sahipse, onlara güvenebiliriz, böylece bir şeyleri kırabilecek herhangi bir değişiklik olduğunda geniş bir hata yelpazesini yakalamak için onlara güvenebiliriz. Bu testlerin gerçekten anlamlı olabilmesi için onları sık sık çalıştırmamız ve başarısız olduklarında hemen haberdar olmamız gerekir. Sürekli entegrasyon kurmak bu konuda yardımcı olabilir. Bu yönde bir diğer adım, yeni kodu kullanıcılarımıza göndermeden önce bu test ortamına dağıtabileceğimiz bir test ortamına sahip olmaktır. Bu iki amaca hizmet eder. İlk olarak, yazılımı kullanıcılar tarafından nasıl görüleceğine dair detaylı bir kontrol yapabiliriz. Yazılımın türüne ve ne kadar sık güncellediğimize bağlı olarak bu ortamda hem otomatik hem de manuel testler yapabiliriz. İkinci olarak, bu test ortamını sorunlar ortaya çıktığında sorun gidermek için kullanabiliriz. Üretim ortamını etkilemeden olası çözümleri ve yeni özellikleri deneyebiliriz. Bu daha da ileri götürülerek, bir bilgisayar filosunu yönetirken başka bir önerilen uygulama, yazılımı aşamalı olarak veya kuşkonmazlarla dağıtmaktır. Bu, tüm bilgisayarları aynı anda yükseltmek ve belki de hepsini aynı anda bozmak yerine önce bazı bilgisayarları yükseltir ve nasıl davrandıklarını kontrol edersiniz anlamına gelir. Her şey yolunda giderse, birkaçını daha yükseltebilir ve filonun geri kalanını yükseltmeye yeterince güvenli olduğunuzda devam edebilirsiniz. Bir deyimde olduğu gibi, bir maden ocağındaki bir kanarya gibi. Bu uygulamayı en iyi şekilde kullanabilmek için önceki sürüme kolayca geri dönebilmemiz gerekir. Yazılıma bağlı olarak, bu daha fazla veya daha az altyapı gerektirebilir. Ancak bana güvenin, bu ek altyapıyı kurmak için zaman harcamak değerlidir. Eğer bozuk bir yazılım sürümünü dağıtırsanız ve aniden bir grup bilgisayarınız düzgün çalışmıyorsa, bunları mümkün olan en kısa sürede önceki durumlarına geri almak istersiniz. Şimdi, tüm bu önleyici önlemlere rağmen, hatalar hala süzülecek ve sorunlar ortaya çıkacaktır. Sorun gidermeyi, kodun içine iyi hata ayıklama kayıtları ekleyerek daha kolay hale getirebiliriz. Bu şekilde, bir sorunu çözmemiz gerektiğinde kayıtlara bakabilir ve neler olduğu konusunda oldukça iyi bir fikir edinebiliriz. Bize yardımcı olabilecek başka bir yöntem de merkezi kayıt toplamaktır. Bu, tüm sunuculardan veya hatta ağdaki tüm bilgisayarlardan tüm kayıtları toplayan özel bir sunucu olduğu anlamına gelir. Böylece kayıtlara bakmamız gerektiğinde her bir makineye ayrı ayrı bağlanmamıza gerek yok, kayıtları merkezi bir sunucuda bir araya getirebiliriz. Benzer şekilde, iyi bir izleme sistemine sahip olmak çok yardımcı olabilir. Onu kullanarak sorunları kullanıcıları çok etkilemeden önce erken yakalayabiliriz. Bir hata ayıklama oturumu sırasında toplanan verilere bakarak, olağandışı bir durum olup olmadığını belirlemeye çalışabiliriz. Ticket sistemlerini birkaç kez önemsedik çünkü onların önemini yeterince vurgulayamayız. Onları iyi kullanmak, bir sorunun temelini bulmaya çalışırken çok zaman kazanmamıza yardımcı olabilir. Kullanıcılardan gerekli bilgileri önceden sağlamalarını isteyerek zaman kaybetmemize ve geri dönmemize gerek kalmaz. Burada bile otomasyon fırsatlarına bakabiliriz. Kullanıcılardan bilgisayarlarından bazı belirli bilgileri neredeyse her zaman istiyorsanız, istediğiniz tüm verileri toplayan bir script oluşturarak bunu otomatikleştirebilir ve kullanıcıların bunu bilete eklemelerini sağlayabilirsiniz. Son olarak, belgeleri yazmaya zaman ayırdığınızdan emin olun. Aynı derecede önemli olan şey, belgeleri iyi bilinen bir konumda saklamaktır. Belgeler yazmak özellikle eğlenceli olmasa da, belirli bir sorunu nasıl çözeceğiniz konusunda iyi talimatlar, sunucu üzerinde neler olduğunu nasıl teşhis edeceğiniz veya bir sistemdeki bilinen sorunları takip etme konusunda iyi bilgi sahibi olmak gerçek zaman tasarrufu sağlayabilir. Google'da, Playbook adını verdiğimiz bir dizi belgeye sahibiz. Bu belgelerde, nöbetçi olan bir kişinin bir ton farklı sorunu teşhis etmek ve hafifletmek için ne yapabileceğini detaylandırıyoruz. Bu bilgi tabanına ekibin biriktirdiği bilgiye herkesin erişim sağlanarak bu bilgiyi güncel tutuyoruz. Burada durmuyor. Eğer değişen ve büyüyen sistemlerle uğraşıyorsak, gelecekte ihtiyacımız olacak ek kapasite için proaktif bir şekilde planlama yapabiliriz. İleriye dönük planlama hakkında daha fazla bilgi almak için bir sonraki videomuzu bekleyebilirsiniz.

Something that IT specialists and exterminators have in common is dealing with bugs. I just love a good coding joke. Anyhow, moving on, it can be bugs in our software or someone else's software. But we'll come across lots of bugs that trigger lots of different failures in our programs. There's a bunch of strategies we can adopt to make our lives easier, by catching issues before they affect our users or making troubleshooting simpler by having better information. We've touched upon some of them here and there but now, it's time to deep dive. To avoid having to scramble to fix things when there's an outage, it's really helpful to have infrastructure that lets us test changes in advance so that we can check that things are working as expected before they reach our users. If we're the ones writing the code, one thing we can do is to make sure that our code has good unit tests and integration tests. If our tests have good coverage of the code, we can rely on them to catch a wide array of bugs whenever there's a change that may break things. For these tests to be really meaningful, we need to run them often, and make sure we know as soon as they fail. Setting up continuous integration can help with that. Another step in this direction is to have a test environment, where we can deploy new code before shipping it to the rest of our users. This serves two purposes. First, we can do a thorough check of the software as it will be seen by the users. Depending on the software and how often we update it, we can do both automated and manual tests in this environment. Second, we can use this test environment to troubleshoot problems whenever they happen. We can try possible solutions and new features without affecting the production environment. Taking this even further, another recommended practice when managing a fleet of computers is to deploy software in phases or canaries. What this means is that instead of upgrading all computers at the same time and possibly breaking all of them at the same time, you upgrade some computers first and check how they behave. If everything goes fine, you can upgrade a few more, and so on until you're confident enough to upgrade the remaining part of the fleet. As the saying goes, like a canary in a coal mine. To make the best use of this practice, we'll need to be able to easily roll back to the previous version. Depending on the software, this might require more or less infrastructure. But trust me, it's worth spending the time setting up that additional infrastructure. If you deploy to software version that was broken and suddenly a bunch of your computers aren't working correctly, you'll want to roll them back to a previous state as fast as possible. Now, even with all these preventative measures, bugs will still filter through and problems will occur. We can make our troubleshooting easier by including good debug logging in the code. That way, whenever we have to figure out an issue, we can look at the logs and get a pretty good idea of what's going on. Another method that can help us is having centralized logs collection. This means there's a special server that gathers all the logs from all the servers or even all the computers in the network. That way, when we have to look at those logs, we don't need to connect to each machine individually, we can comb through all the logs together in a centralized server. Similarly, having a good monitoring system can be super helpful. We can use it to catch issues early before they affect too many users. During a debugging session, we can look at the collected data to try to determine if there's anything out of the ordinary going on. We called out ticketing systems a few times already, because we can't stress their importance enough. Making good use of them can help us save a lot of time when trying to get to the bottom of a problem. If we ask users to provide the needed information up front, we don't have to waste time and go back and forth. Even here, we can look at opportunities for automation. Say you almost always want some specific info from the users computers, you can automate getting it by creating a script that gathers all the data you want and have the users attach it to the ticket. Finally, remember to spend time writing documentation. Just as importantly, store the documentation in a well-known location. Even if writing documentation isn't especially fun, having good instructions on how to solve a specific problem, knowing how to diagnose what's going on with the server, or tracking the known issues in a system can be real time savers. At Google, we have a bunch of docs called Playbooks where we detail what a person who's on call can do to diagnose and mitigate a ton of different problems. By keeping this information updated, we make sure that no matter who the person on call is, everybody has access to the knowledge base accumulated by the whole team. It doesn't stop there. If we're dealing with systems that change and grow, we can proactively plan for the additional capacity that we'll need in the future. Speaking of planning ahead, you can plan to hear more about this in our next video.